YPP-14754 addClient
===================

public PartnerApisResponse addClient(PartnerApisRequest request, Partner partner) {
        log.info("Request to add client {} for partner {}", request, partner.getId());
        try {
            //Check for DCA program
            List<PartnerProgram> partnerPrograms = this.partnerProgramRepository.findByPartnerIdAndStatus(partner.getId(), Status.ACTIVE);
            boolean access = partnerPrograms.stream()
                .anyMatch(partnerProgram -> "CLIENT_PROGRAM".equals(partnerProgram.getYpHubProgram().getName()));
            if (!access) {
                log.info("DCA progaram is not enabled for the partner {}", partner.getId());
                return new PartnerApisResponse(DAErrorCode.API_ACCESS_NOT_GIVEN);
            }
            if (StringUtils.isAnyBlank(request.getRequestId(), request.getP1(), request.getP2(),
                request.getP3(), request.getP4(), request.getP5(), request.getP6(), request.getP7(), request.getP9())) {
                return new PartnerApisResponse(DAErrorCode.PARAMETER_MISSING);
            }
            String pan = request.getP1().toUpperCase();
            Long partnerId = partner.getId();
            PartnerClient partnerClient = new PartnerClient();
			partnerClient.setDueDiligenceStatus(DueDiligenceStatusEnum.FDD);
            if (pan.length() != 10 || !fourthLetter.contains(pan.charAt(3))) {
            	log.info("Invalid pan while adding client through YPHub : {} and pan charAt(3): {} and length of Pan : {} ", pan, pan.charAt(3), pan.length());
                log.info("Invalid pan {}", pan);
                return new PartnerApisResponse(DAErrorCode.INVALID_PAN);
            } else if (!request.getP2().matches("^[a-zA-Z0-9./ ]+$")) {
                log.info("Invalid Name {}", request.getP2());
                return new PartnerApisResponse(DAErrorCode.INVALID_NAME);
            } else if (!request.getP3().matches("^[A-Za-z0-9]{3}$")) {
                log.info("Invalid Client Id {}", request.getP3());
                return new PartnerApisResponse(DAErrorCode.INVALID_CLIENT_IDENTIFIER);
            } else if (!request.getP4().matches("^[0-9]{10}$")) {
                log.info("Invalid Mobile No {}", request.getP4());
                return new PartnerApisResponse(DAErrorCode.INVALID_MOBILE);
            } else if (!request.getP5().matches("^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,50}$")) {
                log.info("Invalid Email Id {}", request.getP5());
                return new PartnerApisResponse(DAErrorCode.INVALID_EMAIL);
            } else if (!request.getP6().matches("^[A-Za-z0-9]*$")) {
                log.info("Invalid Source Account {}", request.getP6());
                return new PartnerApisResponse(DAErrorCode.INVALID_SOURCE_ACCOUNT_NO);
            } else if (!RandomUtil.isValidIFSCode(request.getP7())) {
                log.info("Invalid Source IFSC code {}", request.getP7());
                return new PartnerApisResponse(DAErrorCode.INVALID_SOURCE_ACCOUNT_IFSC);
            } else if (StringUtils.isNotBlank(request.getP8()) && !request.getP8().toUpperCase().matches("^[0-9]{2}[A-Z]{5}[0-9]{4}[A-Z]{1}[1-9A-Z]{1}Z[0-9A-Z]{1}$")) {
                log.info("Invalid GST Number {}", request.getP8());
                return new PartnerApisResponse(DAErrorCode.INVALID_GST);
            } else if (StringUtils.isNotBlank(request.getP8()) && !request.getP8().substring(2, 12).equalsIgnoreCase(pan)) {
                log.info("Invalid GST Number {}", request.getP8());
                return new PartnerApisResponse(DAErrorCode.INVALID_GST);
            }
			List<String> programTypeList = Arrays.asList(PartnerClientPurposeEnum.DC_AGGREGATOR.name(),
					PartnerClientPurposeEnum.TRADE.name(),PartnerClientPurposeEnum.GIFT_CARD.name(), PartnerClientPurposeEnum.CONSUMER_MGMT.name(), PartnerClientPurposeEnum.MSVD.name());
			if (!programTypeList.contains(request.getP9())) {
				log.info("Invalid program type {}", request.getP9());
				return new PartnerApisResponse(DAErrorCode.CLIENT_BEING_ONBOARDED_WITH_INVALID_PURPOSE);
			}

			Optional<ClientValidationConfig> clientValidationConfigOptional = clientValidationConfigRepository.findByPartnerIdAndPurpose(partnerId, PurposeClientValidationConfigEnum.valueOf(request.getP9()));
			if(!clientValidationConfigOptional.isPresent()) {
				log.info("Client validation config is missing for partner {}", partner.getId());
				 return new PartnerApisResponse(DAErrorCode.PARTNER_CONFIGURATION);
			}
			if(clientValidationConfigOptional.isPresent() && null != clientValidationConfigOptional.get().getCustomECollectNumber() && clientValidationConfigOptional.get().getCustomECollectNumber()){
            if (StringUtils.isAnyBlank(request.getP10())) {
                return new PartnerApisResponse(DAErrorCode.PARAMETER_MISSING);
            }
                // Invalid E Collect Number
                if (!request.getP10().matches("[a-zA-Z0-9]+")) {
                    log.info("Invalid E Collect Number, {}", request.getP10());
                    return new PartnerApisResponse(DAErrorCode.INVALID_E_COLLECT_NO);
                }
                if (request.getP10().length()<6) {
                	log.info("E collect code Number should be atleast 6, {},", request.getP5());
                	//invalid e collect account no
                	return new PartnerApisResponse(DAErrorCode.INVALID_E_COLLECT_NO);
                }
                if (request.getP10().length()>25 || !request.getP10().substring(0, 6).equals(clientValidationConfigOptional.get().geteCollectAccountCode())) {
                    log.info("Invalid e collect code Number, {}, request.getP5()");
                    //invalid e collect account no
                    return new PartnerApisResponse(DAErrorCode.INVALID_E_COLLECT_NO);
                }

                if(eCollectAccountRepository.existsByAccountNo(request.getP10())) {
                    log.info("E Collect Number already taken, {}", request.getP10());
                    return new PartnerApisResponse(DAErrorCode.E_COLLECT_NUMBER_ALREADY_PRESENT);
                }
            }

            if (partnerClientRepository.existsByPanAndPartnerId(pan, partnerId)) {
                log.info("Pan {} already exists", pan);
                return new PartnerApisResponse(DAErrorCode.PAN_ALREADY_EXIST);
            } else if (partnerClientRepository.existsByClientIdentifierAndPartnerId(request.getP3(), partnerId)) {
                log.info("Client Id {} already exists", request.getP3());
                return new PartnerApisResponse(DAErrorCode.CLIENT_ID_EXISTS);
            } else if (partnerClientRepository.existsByMobileNumberAndPartnerId(request.getP4(), partnerId)) {
                log.info("Mobile No {} already exists", request.getP4());
                return new PartnerApisResponse(DAErrorCode.MOBILE_NO_ALREADY_EXIST);
            } else if (partnerClientRepository.existsByEmailAndPartnerId(request.getP5(), partnerId)) {
                log.info("Email {} already exists", request.getP5());
                return new PartnerApisResponse(DAErrorCode.EMAIL_ALREADY_EXIST);
			}

			if (PartnerClientPurposeEnum.DC_AGGREGATOR.name().equals(request.getP9())) {
				if (!partnerPrograms.stream().anyMatch(
						partnerProgram -> "DC_AGGREGATOR".equals(partnerProgram.getYpHubProgram().getName()))) {
					log.info("Invalid program type {} with partner program", request.getP9());
					return new PartnerApisResponse(DAErrorCode.CLIENT_BEING_ONBOARDED_WITH_INVALID_PURPOSE);
				}
			} else if (PartnerClientPurposeEnum.TRADE.name().equals(request.getP9())) {
				if (!partnerPrograms.stream()
						.anyMatch(partnerProgram -> "TRADE".equals(partnerProgram.getYpHubProgram().getName()))) {
					log.info("Invalid program type {} with partner program", request.getP9());
					return new PartnerApisResponse(DAErrorCode.CLIENT_BEING_ONBOARDED_WITH_INVALID_PURPOSE);
				}
			} else if (PartnerClientPurposeEnum.GIFT_CARD.name().equals(request.getP9())) {
				if (!partnerPrograms.stream()
						.anyMatch(partnerProgram -> "GIFT_CARD".equals(partnerProgram.getYpHubProgram().getName()))) {
					log.info("Invalid program type {} with partner program", request.getP9());
					return new PartnerApisResponse(DAErrorCode.CLIENT_BEING_ONBOARDED_WITH_INVALID_PURPOSE);
				}
			} else if (PartnerClientPurposeEnum.CONSUMER_MGMT.name().equals(request.getP9())) {
				if (!partnerPrograms.stream()
						.anyMatch(partnerProgram -> "CONSUMER_PROGRAM".equals(partnerProgram.getYpHubProgram().getName()))) {
					log.info("Invalid program type {} with partner program and yphub prgm {}", request.getP9(), partnerPrograms.get(0).getYpHubProgram().getName());
					return new PartnerApisResponse(DAErrorCode.CLIENT_BEING_ONBOARDED_WITH_INVALID_PURPOSE);
				}
			} else if (PartnerClientPurposeEnum.MSVD.name().equals(request.getP9())) {
				if (!partnerPrograms.stream().anyMatch(
						partnerProgram -> "PAYMENT_DISBURSEMENT".equals(partnerProgram.getYpHubProgram().getName()))) {
					log.info("Invalid program type {} with partner program", request.getP9());
					return new PartnerApisResponse(DAErrorCode.CLIENT_BEING_ONBOARDED_WITH_INVALID_PURPOSE);
				}
			}
			//check count on purpose level
			boolean gstVerified = false;
			//Optional<PartnerDASetup> daSetupOpt = Optional.empty();
			Optional<ClientValidationConfig> clientValidationConfigOpt = Optional.empty();
			if (PartnerClientPurposeEnum.DC_AGGREGATOR.name().equals(request.getP9())) {
				//daSetupOpt = partnerDASetupRepository.findByPartnerId(partnerId);
                 clientValidationConfigOpt =  clientValidationConfigRepository.findByPartnerIdAndPurpose(partnerId, PurposeClientValidationConfigEnum.valueOf(request.getP9()));
				//if(!daSetupOpt.isPresent()) {
                if(!clientValidationConfigOpt.isPresent()){
					log.info("DC Aggregator configuration missing for purpose {}", request.getP9());
                    return new PartnerApisResponse(DAErrorCode.PARTNER_CONFIGURATION);
				}
				Integer clientByPartnerCount = partnerClientRepository.countByPartnerIdAndPurpose(partnerId, PartnerClientPurposeEnum.valueOf(request.getP9()));
				//if (clientByPartnerCount >= daSetupOpt.get().getMaximumClients()) {
                if (clientByPartnerCount >= clientValidationConfigOpt.get().getMaximumClients()) {
					//log.info("Client Count {} and Max client for partner {}", clientByPartnerCount, daSetupOpt.get().getMaximumClients());
                    log.info("Client Count {} and Max client for partner {}", clientByPartnerCount, clientValidationConfigOpt.get().getMaximumClients());
                    return new PartnerApisResponse(DAErrorCode.MAXIMUM_NO_CLIENT_ADDITION_REACHED);
				}
				if(clientValidationConfigOpt.isPresent()) {
					gstVerified = clientValidationConfigOpt.get().isGstValidation();
				}
			} else if(PartnerClientPurposeEnum.GIFT_CARD.name().equals(request.getP9())) {
				clientValidationConfigOpt = clientValidationConfigRepository.findByPartnerIdAndPurpose(partnerId, PurposeClientValidationConfigEnum.valueOf(request.getP9()));
				if(!clientValidationConfigOpt.isPresent()) {
					log.info("clientValidation configuration missing for purpose {]", request.getP9());
					return new PartnerApisResponse(DAErrorCode.PARTNER_CONFIGURATION);
				}
				Integer gcClientCount = partnerClientRepository.countByPartnerIdAndPurpose(partnerId,PartnerClientPurposeEnum.GIFT_CARD);
				if (gcClientCount >= clientValidationConfigOpt.get().getMaximumClients()) {
					log.info("Client Count {} and Max client for partner {}", gcClientCount, clientValidationConfigOpt.get().getMaximumClients());
					return new PartnerApisResponse(DAErrorCode.MAXIMUM_NO_CLIENT_ADDITION_REACHED);
				}
				if(clientValidationConfigOpt.isPresent()) {
					gstVerified = clientValidationConfigOpt.get().isGstValidation();
				}
			} else if(PartnerClientPurposeEnum.CONSUMER_MGMT.name().equals(request.getP9())) {
                clientValidationConfigOpt = clientValidationConfigRepository.findByPartnerIdAndPurpose(partnerId, PurposeClientValidationConfigEnum.valueOf(request.getP9()));
                if(!clientValidationConfigOpt.isPresent()) {
    					log.info("clientValidation configuration missing for purpose {]", request.getP9());
    					return new PartnerApisResponse(DAErrorCode.PARTNER_CONFIGURATION);
                }
                Integer consumerClientCount = partnerClientRepository.countByPartnerIdAndPurpose(partnerId, PartnerClientPurposeEnum.CONSUMER_MGMT);
                if (consumerClientCount >= clientValidationConfigOpt.get().getMaximumClients()) {
                    log.info("Client Count {} and Max client for partner {}", consumerClientCount, clientValidationConfigOpt.get().getMaximumClients());
                    return new PartnerApisResponse(DAErrorCode.MAXIMUM_NO_CLIENT_ADDITION_REACHED);
                }
			} else if (PartnerClientPurposeEnum.MSVD.name().equals(request.getP9())) {
				Optional<PartnerPDSetup> partnerPDSetupInfo = partnerPDSetupRepository.findByPartnerId(partnerId);
				if (!partnerPDSetupInfo.isPresent() || null == partnerPDSetupInfo.get().getMsvdChannel() || null == partnerPDSetupInfo.get().getMsvdFundSource()
						|| !MSVDFundSourceEnum.CLIENT_LIMIT.equals(partnerPDSetupInfo.get().getMsvdFundSource())) {
					log.info("DC Aggregator configuration missing for purpose {}", request.getP9());
					return new PartnerApisResponse(DAErrorCode.PARTNER_CONFIGURATION);
				}
				clientValidationConfigOpt =  clientValidationConfigRepository.findByPartnerIdAndPurpose(partnerId, PurposeClientValidationConfigEnum.valueOf(request.getP9()));
				if(!clientValidationConfigOpt.isPresent()){
					log.info("DC Aggregator configuration missing for purpose {}", request.getP9());
					return new PartnerApisResponse(DAErrorCode.PARTNER_CONFIGURATION);
				}
				Integer clientByPartnerCount = partnerClientRepository.countByPartnerIdAndPurpose(partnerId, PartnerClientPurposeEnum.valueOf(request.getP9()));
				if (clientByPartnerCount >= clientValidationConfigOpt.get().getMaximumClients()) {
					log.info("Client Count {} and Max client for partner {}", clientByPartnerCount, clientValidationConfigOpt.get().getMaximumClients());
					return new PartnerApisResponse(DAErrorCode.MAXIMUM_NO_CLIENT_ADDITION_REACHED);
				}
				if(clientValidationConfigOpt.isPresent()) {
					gstVerified = clientValidationConfigOpt.get().isGstValidation();
				}
			}
			//gst validation with purpose base
			if(gstVerified && StringUtils.isBlank(request.getP8())) {
				if("YPHUB".equals(request.getChannel()))
					return new PartnerApisResponse(DAErrorCode.PROVIDE_VALID_GST);
				else
					return new PartnerApisResponse(DAErrorCode.PARAMETER_MISSING);
			}
			// pan verification
			log.debug("PAN Verification process start: {}", pan);
			PanVerificationDetails panVerificationDetails = createPanVerification(pan);
			try {
				String responseObj = null;
				if (Arrays.asList(env.getActiveProfiles()).contains("prod")) {
					responseObj = getPanCardData.getPanCardData(pan); // Call to NSDL api
				} else {
					responseObj = dummyApiResponseRepository.findByKeyAndApiNameAndValue("Pan", ApiNameEnum.NSDL, pan).orElse(new DummyApiResponse()).getApiResponse();
					if (StringUtils.isBlank(responseObj))
						responseObj = getPanCardData.getPanCardData(pan); // Call to NSDL api
				}
				JSONObject responseJson = new JSONObject(responseObj);
				PanCardDataDto panCardDataDto = new ObjectMapper().readValue(responseJson.getJSONObject("PANRes").toString(), PanCardDataDto.class);
				if (null != panCardDataDto && !panCardDataDto.getErrorCode().equals("01") && "E".equals(panCardDataDto.getExist())) {
					String clientName = request.getP2().toLowerCase();
					panVerificationDetails.panData(responseObj).firstName(panCardDataDto.getFirstname()).lastName(panCardDataDto.getLastname()).middleName(panCardDataDto.getMiddlename()).issueDate(panCardDataDto.getIssueDate());
					panVerificationDetails.setPanDisplayName(panCardDataDto.getNameOnCard());
					panVerificationDetailsRepository.save(panVerificationDetails);
					if(!(clientName.contains(panCardDataDto.getFirstname().toLowerCase()) && clientName.contains(panCardDataDto.getLastname().toLowerCase()))) {
						log.info("PAN details mismatch clientName: {} , panCardDataDto: {}", clientName, panCardDataDto);
						return new PartnerApisResponse(DAErrorCode.PAN_DETAILS_MISMATCH);
					}
				} else {
					log.info("Pan {} is invalid", pan);
					return new PartnerApisResponse(DAErrorCode.INVALID_PAN);
				}
				log.debug("PAN Verification process end: {}", pan);
			} catch (IOException e) {
				log.error("Unable to verify Pan, please try again later for IOException: {}", e);
				return new PartnerApisResponse(DAErrorCode.INVALID_PAN);
			}
			// updating client details
			partnerClient.setDueDiligenceStatus(DueDiligenceStatusEnum.PAN_VERIFIED);
            partnerClient.clientIdentifier(request.getP3()).clientName(request.getP2()).pan(pan).mobileNumber(request.getP4()).email(request.getP5()).partner(partner).status(Status.ACTIVE);
            partnerClient.setChannel(ChannelEnum.valueOf(request.getChannel()));
            if (!StringUtils.isBlank(request.getP8())) {
                partnerClient.gstn(request.getP8().toUpperCase());
            }
            if ("YPHUB".equals(request.getChannel())) {
                Optional<YPHubUser> yphubUserOptional = this.getLoginUser();
                if (yphubUserOptional.isPresent()) {
                    partnerClient.setOnBoardedBy(yphubUserOptional.get().getId());
                }
            } else {
                Optional<YPHubUser> yphubUserOptional = this.ypHubUserRepository.findByOwnerIdAndOwnerTypeAndStatus(partner.getId(), OwnerTypeEnum.PARTNER, Status.ACTIVE);
                if (yphubUserOptional.isPresent()) {
                    partnerClient.setOnBoardedBy(yphubUserOptional.get().getId());
                }
            }
            //gst verification
            KarzaGstVerificationInfo gstVerificationInfo = null;
            GstMaster gstMaster = null;
            if (StringUtils.isNotBlank(request.getP8()) && gstVerified) {
            	log.debug("Gst Verification process start: {}", request.getP8());
            	gstVerificationInfo = createGstVerificationInfoForAddClient(request.getP8(), partner);
                try {
                    String response = null;
                    if (Arrays.asList(env.getActiveProfiles()).contains("prod")) {
                        response = gstService.commonGstVerification(request.getP8());
                    } else {
                        response = dummyApiResponseRepository.findByKeyAndApiNameAndValue("GST", ApiNameEnum.GST_VERIFICATION, request.getP8()).orElse(new DummyApiResponse()).getApiResponse();
                        if (StringUtils.isBlank(response))
                            response = gstService.commonGstVerification(request.getP8());
                    }
                    GstVerificationResponse verificationResponse = new ObjectMapper().readValue(response, GstVerificationResponse.class);
                    log.info("Karza GST verification response {}", verificationResponse);
                    if(null != verificationResponse)
                        gstVerificationInfo.requestId(verificationResponse.getRequestId()).statusCode(verificationResponse.getStatusCode());
                    if (StringUtils.isNotBlank(verificationResponse.getStatusCode()) && verificationResponse.getStatusCode().equalsIgnoreCase("101")
                            && null != verificationResponse.getResult() && "Active".equalsIgnoreCase(verificationResponse.getResult().getSts()) ) {
                        log.info("Gst Verified successfully");
                        GstResult result = verificationResponse.getResult();
                        gstVerificationInfo.legalName(result.getLgnm()).registrationStatus(result.getSts()).registrationDate(result.getRgdt()).natureOfBusiness(new JSONArray(result.getNba()).toString())
                                .address(result.getPradr().getAdr()).ownershipType(result.getCtb());
                        partnerClient.setDueDiligenceStatus(DueDiligenceStatusEnum.GST_VERIFIED);
                        karzaGstVerificationInfoRepository.save(gstVerificationInfo);
                        gstMaster = createGSTMaster(partner, gstVerificationInfo, request, verificationResponse);
                        //gstMasterRepository.save(gstMaster);
                    } else if (StringUtils.isNotBlank(verificationResponse.getStatusCode()) && verificationResponse.getStatusCode().equalsIgnoreCase("101")
                            && null != verificationResponse.getResult() && !"Active".equalsIgnoreCase(verificationResponse.getResult().getSts()) ) {
                        log.info("Gst Verification Failed : Gst not active");
                        GstResult result = verificationResponse.getResult();
                        gstVerificationInfo.legalName(result.getLgnm()).registrationStatus(result.getSts()).registrationDate(result.getRgdt()).natureOfBusiness(null != result.getNba() ? new JSONArray(result.getNba()).toString() : null)
                        .address(null != result.getPradr() ? result.getPradr().getAdr() : null).ownershipType(result.getCtb());
                        persistKarzaDetails(gstVerificationInfo);
                        return new PartnerApisResponse(DAErrorCode.GST_NOT_ACTIVE);
                    } else if (StringUtils.isNotBlank(verificationResponse.getStatusCode()) && !verificationResponse.getStatusCode().equalsIgnoreCase("101")) {
                        log.info("Gst Verification Failed: Invalid Gst Number");
                        persistKarzaDetails(gstVerificationInfo);
                        return new PartnerApisResponse(DAErrorCode.INVALID_GST);
                    } else {
                        log.error("Unable to verify GST, please try again later for other failure and timeout cases: {}");
                        persistKarzaDetails(gstVerificationInfo);
                        return new PartnerApisResponse(DAErrorCode.TIMEOUT_GST_VERIFICATION);
                    }
                } catch (IOException e) {
                    log.error("Unable to verify GST, please try again later for IOException: {}", e);
                    gstVerificationInfo.setStatusCode("timeout");
                    persistKarzaDetails(gstVerificationInfo);
                    return new PartnerApisResponse(DAErrorCode.TIMEOUT_GST_VERIFICATION);
                }
                log.debug("Gst Verification process ends: {}", request.getP8());
            }
            //source account verification
            PartnerClientSourceAccount sourceAccount = new PartnerClientSourceAccount().accountNumber(request.getP6()).ifscCode(request.getP7()).status(Status.ACTIVE);
            String partnerCode = partner.getPartnerCode();
            YPHubUser user = new YPHubUser().ownerType(OwnerTypeEnum.PARTNER_CLIENT).communicationMode(CommunicationModeEnum.E)
                .userName(partnerCode + "C." + partnerClient.getClientIdentifier()).name(partnerClient.getClientName()).status(Status.ACTIVE);
            ECollectAccount eCollectAccount = new ECollectAccount().ownerType(ECollectOwnerEnum.PARTNER_CLIENT).partner(partnerClient.getPartner())
                .accountNo((null != clientValidationConfigOptional.get().getCustomECollectNumber() && clientValidationConfigOptional.get().getCustomECollectNumber()) ? request.getP10(): getEcollectAccountNumber());
            partnerClient.setEcollectNumber(eCollectAccount.getAccountNo());
            partnerClient.setPurpose(PartnerClientPurposeEnum.valueOf(request.getP9()));

            Boolean sourceAccountVerification = Boolean.FALSE;

            Long accountVerificationRecordId = null;
            Boolean isAccVerified = Boolean.FALSE;
            if (clientValidationConfigOpt.isPresent() && clientValidationConfigOpt.get().isSourceAccountVerification()) {
            	log.debug("Account Verification process start");
            	//call common account verfication method
            	String karzaType = "individual";
            	Boolean manualSourceAccVerification = clientValidationConfigOpt.get().getManualSourceAccVerification();
            	try {
            		AccountVerificationResponseDto verificationResponseDto = accountVerificationService.accountVerificationProcess(
            				request.getP6(), request.getP7(), Boolean.FALSE, request.getP2(), request.getP1(), null, ChannelEnum.INTERNAL, partner,
            				AccountOwnerType.CLIENT_SOURCE_ACCOUNT.name(), null, karzaType, null);
            		log.info("verificationResponse: {}", verificationResponseDto);
            		if (null != verificationResponseDto && null != verificationResponseDto.getAccountVerificationStatus() && AccountVerificationStatusEnum.SUCCESS.equals(verificationResponseDto.getAccountVerificationStatus())) {
            			accountVerificationRecordId = verificationResponseDto.getAccountVerificationRecord().getId();
            			Boolean isAccVerifiedWithTable = Boolean.FALSE;
            			if (AccountVerificationModeEnum.ACC_VER_TABLE.equals(verificationResponseDto.getAccountVerificationMode())) {
            				AccountVerificationRecord accountVerificationRecord = verificationResponseDto.getAccountVerificationRecord();
            				log.debug("AccountVerificationMode: {}, for accountVerificationRecord Id: {} and ActualAccVerificationRecord's Id: {}", verificationResponseDto.getAccountVerificationMode(), accountVerificationRecordId, accountVerificationRecord.getAccountVerificationId());
            				Optional<AccountVerificationRecord> actualAccVerificationRecordInfo = accountVerificationRecordRepository.findById(accountVerificationRecord.getAccountVerificationId());
            				if (actualAccVerificationRecordInfo.isPresent() && !AccountVerificationModeEnum.PAN_ACCOUNT_API.equals(actualAccVerificationRecordInfo.get().getAccountVerificationMode())) {
            					isAccVerifiedWithTable = Boolean.TRUE;
            					log.debug("ActualAccVerificationRecords AccountVerificationMode: {} and isAccVerifiedWithTable: {}", actualAccVerificationRecordInfo.get().getAccountVerificationMode(), isAccVerifiedWithTable);
            				}
            			}
						if (null != panVerificationDetails && null != verificationResponseDto.getAccountVerificationMode()
								&& (Arrays.asList(AccountVerificationModeEnum.UNIVERSAL_VPA_VALIDATION, AccountVerificationModeEnum.PENNY_DROP_IMPS).contains(verificationResponseDto.getAccountVerificationMode())
									|| isAccVerifiedWithTable)) {
            				log.info("Nsdl Request panFirstName : {}, panLastName: {}, nameOnCard: {}, nameToCompare: {}, partner: {}, ownerType: {}, ownerId: {}, isNameToCompareVerified: {}, type:{}",panVerificationDetails.getFirstName(), panVerificationDetails.getLastName(), request.getP2(), verificationResponseDto.getVerifiedAccountName(), partner, KycOwnerType.PARTNER_CLIENT.name(), partnerClient.getId(), Boolean.FALSE, karzaType);
            				NsdlNameMatchResponse response = nsdlNameMatchService.nsdlNameMatchProcess(panVerificationDetails.getFirstName(), panVerificationDetails.getLastName(), panVerificationDetails.getPanDisplayName(), verificationResponseDto.getVerifiedAccountName(), partner, KycOwnerType.PARTNER_CLIENT.name(), partnerClient.getId(), Boolean.FALSE, karzaType);
            				log.info("NsdlNameResponse : {}", response);
            			    if (null != response && null != response.getStatus() && response.getStatus().equalsIgnoreCase(AccountVerificationStatusEnum.TIMEOUT.name())) {
            					log.info("Exception in name matching method : {}" + response.getStatus());
            					return new PartnerApisResponse(DAErrorCode.CLIENT_COULD_NOT_BE_ONBOARDED_AS_NAME_MATCHING_REQUEST_TIMED_OUT);
            				} else if (null != response && null != response.getMatch() && !response.getMatch()) {
            					log.info("Agent details doesn’t match with PAN details: {}", panVerificationDetails);
            					return new PartnerApisResponse(DAErrorCode.CLIENT_COULD_NOT_ON_BE_ONBOARDED_AS_NAME_DOES_NOT_MATCH_WITH_ACCOUNT_NAME);
            				}
            			}
            			isAccVerified = Boolean.TRUE;
            		} else {
            			if (!manualSourceAccVerification && AccountVerificationStatusEnum.FAILED.equals(verificationResponseDto.getAccountVerificationStatus())) {
            				log.info("Account verification failed for partner client pan {} account no {} , ifscCode {} ", pan, request.getP6(), request.getP7());
            				return new PartnerApisResponse(DAErrorCode.CLIENT_COULD_NOT_BE_ONBOARDED_AS_SOURCE_ACCOUNT_VERIFICATION_FAILED);
            			} else if (!manualSourceAccVerification && AccountVerificationStatusEnum.TIMEOUT.equals(verificationResponseDto.getAccountVerificationStatus())) {
            				log.info("Account verification timed out for partner client pan {} account no {} , ifscCode {} ", pan, request.getP6(), request.getP7());
            				return new PartnerApisResponse(DAErrorCode.CLIENT_COULD_NOT_BE_ONBOARDED_AS_SOURCE_ACCOUNT_VERIFICATION_REQUEST_TIMED_OUT);
            			}
            		}
            	} catch (Exception e) {
            		log.error("Exception in AccountVerification, {}", e);
            		return new PartnerApisResponse(DAErrorCode.UNABLE_TO_ADD_PARTNER_CLEINT);
            	}
            	log.debug("Account Verification process ends");
            }
            // onboard client
			partnerClient = partnerClientService.create(partnerClient, sourceAccount, panVerificationDetails, user, eCollectAccount, accountVerificationRecordId, gstVerificationInfo, gstMaster, isAccVerified);
			log.info("Async call to amlockApiCall");
		    amlockListCheck(partnerClient);
            PartnerApisResponse response = new PartnerApisResponse();
            response.setRequestId(request.getRequestId());
            response.setClientIdentifier(partnerClient.getClientIdentifier());
            response.setECollectAccountNumber(eCollectAccount.getAccountNo());
            response.setYpHubUsername(user.getUserName());
            response.setStatus("SUCCESS");
            response.setResponseCode("00");
            response.setResponseMessage("Client has been onboarded successfully.");
            return response;
        } catch (Exception e) {
            log.error("Exception ", e);
            return new PartnerApisResponse(DAErrorCode.UNABLE_TO_ADD_PARTNER_CLEINT);
        }
    }

    public String commonGstVerification(String gstn) throws ClientProtocolException, IOException {
        String response = restTemplate.getForObject(
                commonGstVerificationUrl, String.class, gstn);
        return response;
    }

    public String getPanCardData(String panNo) throws Exception {
        String requestJson = getRequestJson(panNo);
        Map<String, String> headers = new HashMap<>();
        headers.put("Authorization", authorization);
        headers.put("Content-Type", "application/json");
        log.info("Request To getPanCardData with Request {}", requestJson);
        String response = dataPowerUtil.postWithDataPower(url, headers, requestJson, Integer.parseInt(timeout),true);
        log.info("Response from getPanCardData with Response {}", response);
		return response;
    }

    private String getRequestJson(String panNo) throws JSONException {
        return new JSONObject().put("pannumber", panNo).toString();
    }

   private KarzaGstVerificationInfo createGstVerificationInfoForAddClient(String gstn, Partner partner) {
		KarzaGstVerificationInfo gstVerificationInfo = new KarzaGstVerificationInfo().ownerType(KarzaGstOwnerType.PARTNER_CLIENT).partner(partner).gstn(gstn);
		return karzaGstVerificationInfoRepository.save(gstVerificationInfo);
	}

// onboard client
    public PartnerClient create(PartnerClient partnerClient, PartnerClientSourceAccount partnerClientSourceAccount, PanVerificationDetails panDetails, YPHubUser user, ECollectAccount eCollectAccount, Long accountVerificationRecordId, KarzaGstVerificationInfo gstVerificationInfo, GstMaster gstMaster, Boolean isAccVerified) throws Exception{
    	log.info("Request to save PartnerClient {}, Source Account {}, PanVerification Details {} ", partnerClient, partnerClientSourceAccount, panDetails);
    	// PartnerClient account creation
    	PartnerClient result = partnerClientRepository.save(partnerClient);
    	log.info("PartnerClient {}", result);
    	// Limit account creation
    	LimitAccount account = new LimitAccount().ownerType(AccountOwnerType.PARTNER_CLIENT).ownerId(result.getId()).currentBalance(BigDecimal.ZERO);
    	limitAccountRepository.save(account);
    	partnerClient.setLimitAccount(account);
    	partnerClientRepository.save(partnerClient);   
    	// partnerClientSourceAccount creation
    	partnerClientSourceAccount.setPartnerClient(result);
    	partnerClientSourceAccount = partnerClientSourceAccountRepository.save(partnerClientSourceAccount);
    	if (null != accountVerificationRecordId) {
    		AccountVerificationRecord accountVerificationRecord = accountVerificationRecordRepository.findById(accountVerificationRecordId).get();
    		log.info("Account Verification Record fetch by id: {}", accountVerificationRecord);
    		partnerClientSourceAccount.setAccountVerificationReferenceId(accountVerificationRecord.getId());
    		partnerClientSourceAccount.setIsAccountVerified(isAccVerified);
    		partnerClientSourceAccount.setAccountVerificationMode(accountVerificationRecord.getAccountVerificationMode().toString());
    		partnerClientSourceAccount = partnerClientSourceAccountRepository.save(partnerClientSourceAccount);
    		log.info("saving owner id as source account id : {}", partnerClientSourceAccount.getId());
    		accountVerificationRecord.setOwnerId(partnerClientSourceAccount.getId());
    		accountVerificationRecordRepository.save(accountVerificationRecord);
    		log.info("saving accountVerificationRecord id : {}", accountVerificationRecord.getId());
    	}
    	// Pan update
    	if (null != panDetails) {
    		panDetails.setOwnerId(result.getId());
    		panVerificationDetailsRepository.save(panDetails);
    	}
    	// Gst update
    	if (null != gstVerificationInfo && null != gstMaster) {
    		gstVerificationInfo.setOwnerId(partnerClient.getId());
    		karzaGstVerificationInfoRepository.save(gstVerificationInfo);
    		gstMaster.setOwnerId(partnerClient.getId().toString());
    		gstMasterRepository.save(gstMaster);
    	}
    	String encryptedPassword = passwordEncoder.encode(RandomUtil.generatePassword());
    	user.ownerId(result.getId()).password(encryptedPassword).lastPasswordSetAt(Instant.now());
    	YPHubUser ypHubUser = ypHubUserRepository.save(user);
    	partnerClient.setYpHubUserId(ypHubUser.getId());
    	result = partnerClientRepository.save(partnerClient);
    	eCollectAccount.ownerId(result.getId());
    	eCollectAccountRepository.save(eCollectAccount);
    	YpHubRole ypHubRole = ypHubRoleRepository.findByName("PARTNER_CLIENT_ROLE").get();
    	YpHubRole ypHubRolePurpose = null;
    	if(PartnerClientPurposeEnum.DC_AGGREGATOR.equals(partnerClient.getPurpose())) {
    		ypHubRolePurpose = ypHubRoleRepository.findByName("CLIENT_DCA_ROLE").get();
    	} else if(PartnerClientPurposeEnum.TRADE.equals(partnerClient.getPurpose())) {
    		ypHubRolePurpose = ypHubRoleRepository.findByName("CLIENT_TRADE_ROLE").get();//not confirm
    	} else if(PartnerClientPurposeEnum.GIFT_CARD.equals(partnerClient.getPurpose())) {
    		ypHubRolePurpose = ypHubRoleRepository.findByName("CLIENT_GC_ROLE").get();
    	}
    	YpHubUserRole userRole = new YpHubUserRole().ypHubRole(ypHubRole).ypHubUser(user);
    	ypHubUserRoleRepository.save(userRole);

    	//Assign MISC_PROGRAM_ADMIN role to partner client
    	YpHubRole ypHubMiscProgramAdminRole = ypHubRoleRepository.findByName("MISC_PROGRAM_ADMIN").get();
    	YpHubUserRole userMiscProgramAdminRole = new YpHubUserRole().ypHubRole(ypHubMiscProgramAdminRole).ypHubUser(user);
    	ypHubUserRoleRepository.save(userMiscProgramAdminRole);

    	if (null != ypHubRolePurpose) {
    		//add purpose role to partner client
    		YpHubUserRole purposeProgramAdminRole = new YpHubUserRole().ypHubRole(ypHubRolePurpose).ypHubUser(user);
    		ypHubUserRoleRepository.save(purposeProgramAdminRole);
    	}

    	if(PartnerClientPurposeEnum.GIFT_CARD.equals(result.getPurpose())){
    		if(!giftCardPurchaserRepository.existsByPanAndPartner(result.getPan(), result.getPartner())) {
    			GiftCardPurchaser purchaser = new GiftCardPurchaser().gstn(result.getGstn()).pan(result.getPan())
    					.partner(result.getPartner()).partnerReferenceNumber("").purchaserName(result.getClientName()) // TODO partner ref no
    					.purchaserType(PurchaserTypeEnum.ENTERPRISE).status(Status.ACTIVE);
    			purchaser.setCreatedBy(partnerClient.getOnBoardedBy());
    			giftCardPurchaserRepository.save(purchaser);
    		}
    	}
    	generateVpa(result);
    	return result;
    }    


     private void generateVpa(PartnerClient client) { 
    	String vpa = Arrays.asList(env.getActiveProfiles()).contains("prod")
    			? "yespay." + client.getPartner().getPartnerCode() + "c" + client.getClientIdentifier() + "@yesbankltd"
    			: "yespay." + client.getPartner().getPartnerCode() + "c" + client.getClientIdentifier() + "@yestransact";
    	DynamicVpa dynamicVpa = new DynamicVpa().partner(client.getPartner()).ownerType(VpaOwnerType.PARTNER_CLIENT)
    			.ownerId(client .getId()).status(VpaStatus.ACTIVE).vpa(vpa.toLowerCase());
    	dynamicVpaRepository.save(dynamicVpa);	
    }

     public AccountVerificationResponseDto accountVerificationProcess(String accountNumber, String ifscCode, Boolean isNameVerification, String nameToBeVerify, String panNumber, List<AccVerModeEnum> verificationModeList, ChannelEnum channel, Partner partner, String ownerType, Long ownerId, String entityType, BigDecimal fees) throws Exception  {
        log.info("account Verification Process Starts With accountNumber: {}, ifscCode: {}, isNameVerification: {}, nameToBeVerify: {}, panNumber: {}, accountValidationModes: {}, channel: {}, partner: {}, ownerType: {}, ownerId: {}",
                accountNumber, ifscCode, isNameVerification, nameToBeVerify, panNumber, verificationModeList, channel,
                partner.getId(), ownerType, ownerId, fees);
        AccountVerificationResponseDto verificationResponseDto = null;
        log.info("common account verification Api Calling");
        AccountVerificationRecord record = null;
        String bankCode = ifscCode.substring(0, 4);
        log.info("bankcode value {}", bankCode);
        ParameterManagement parameterManagement = parameterManagementRepository.findByName(ParameterManagementEnum.DAYS_TILL_ACC_INTERNAL_REVER.name());
        log.info("parameterManagement value: {}", parameterManagement);
        Long days = Long.valueOf(parameterManagement.getValue());
        Instant beforeTime = Instant.now().minus(days, ChronoUnit.DAYS);
        if(StringUtils.isEmpty(panNumber)){
            panNumber = null;
        }
        Optional<AccountVerificationRecord> accountVerificationRecord= accountVerificationRecordRepository.findTopByAccountNumberAndBankCodeAndAccountVerificationStatusAndCreatedDateGreaterThanEqualAndAccountVerificationModeIsNotAndPanNo(
                accountNumber, bankCode, AccountVerificationStatusEnum.SUCCESS, beforeTime, AccountVerificationModeEnum.ACC_VER_TABLE, panNumber);

        log.info("accountVerificationRecord {}",accountVerificationRecord);
        if(accountVerificationRecord.isPresent()) {
            record = createAccountVerificationRecordByBankCode(partner, ownerType, ownerId, accountNumber, ifscCode,
                    nameToBeVerify, channel, isNameVerification, fees, accountVerificationRecord.get().getId(),accountVerificationRecord.get().getVerifiedAccountName(), panNumber);
            if (isNameVerification) {
                verifyName(nameToBeVerify, accountVerificationRecord.get().getVerifiedAccountName(), record, partner, entityType);
            }
            return new AccountVerificationResponseDto(record.getAccountVerificationStatus(), record.getAccountVerificationMode(), record.getNameVerificationStatus(), record.getVerifiedAccountName(), record.getId(), record.getAccountVerificationMessage()).accountVerificationRecord(record);
        }

        record = createAccountVerificationRecord(partner, ownerType, ownerId, accountNumber, ifscCode, nameToBeVerify, channel, isNameVerification, fees, panNumber);
        // PanAccount Api validation
        verificationResponseDto = panAccountVerification(panNumber, record, accountNumber, ifscCode, isNameVerification, nameToBeVerify, ownerType, verificationModeList, partner, entityType);
        if (null != verificationResponseDto && null != verificationResponseDto.getAccountVerificationStatus() && verificationResponseDto.getAccountVerificationStatus().equals(AccountVerificationStatusEnum.SUCCESS)
                || (null != verificationResponseDto && null != verificationResponseDto.getAccountVerificationStatus() && verificationResponseDto.getAccountVerificationStatus().equals(AccountVerificationStatusEnum.FAILED) && null != verificationResponseDto.getReasonCode() && "AV001".equals(verificationResponseDto.getReasonCode())))
            return verificationResponseDto.accountVerificationRecord(record);
        // Universal VPA Validation
        verificationResponseDto = universalVpaValidation(record, accountNumber, ifscCode, isNameVerification, nameToBeVerify, verificationModeList, partner, entityType);
        if (null != verificationResponseDto && null != verificationResponseDto.getAccountVerificationStatus() && verificationResponseDto.getAccountVerificationStatus().equals(AccountVerificationStatusEnum.SUCCESS))
            return verificationResponseDto.accountVerificationRecord(record);
        // PENNY_DROP_IMPS
        verificationResponseDto = pennyDropImps(record, accountNumber, ifscCode, isNameVerification, nameToBeVerify, verificationModeList, entityType);
        if (null != verificationResponseDto)
            return verificationResponseDto.accountVerificationRecord(record);

        return new AccountVerificationResponseDto(record.getAccountVerificationStatus(), record.getAccountVerificationMode(), record.getNameVerificationStatus()).accountVerificationRecord(record);
    }

    private PanVerificationDetails createPanVerification(String pan) {
        PanVerificationDetails details = new PanVerificationDetails();
        details.setPanNo(pan);
        details.setOwnerType(KycOwnerType.PARTNER_CLIENT);
        panVerificationDetailsRepository.save(details);
        return details;
    }
    
  private AccountVerificationRecord createAccountVerificationRecordByBankCode(Partner partner, String ownerType, Long ownerId, String accountNumber, String ifscCode, String nameToBeVerify, ChannelEnum channel, Boolean isNameVerification, BigDecimal fees, Long id, String verifiedAccName, String pan) {
        AccountVerificationRecord record = new AccountVerificationRecord().accountNumber(accountNumber).ifscCode(ifscCode).channel(channel).ownerId(ownerId).ownerType(ownerType).partner(partner)
                .accountVerificationStatus(AccountVerificationStatusEnum.SUCCESS).nameToBeVerified(nameToBeVerify);
        record.setBankCode(ifscCode.substring(0,4));
        record.accountVerificationId(id).accountVerificationMessage("Account verified through existing verified details");
        record.verifiedAccountName(verifiedAccName).setAccountVerificationMode(AccountVerificationModeEnum.ACC_VER_TABLE);
        record.setPanNo(pan);
        if(null != fees) {
            record.setAccountVerificationfees(fees);
        }
        return accountVerificationRecordRepository.save(record);
    }

    private void verifyName(String name1, String name2, AccountVerificationRecord record, Partner partner, String entityType) {
        KarzaNameMatchRequest karzaNameMatchRequest = createKarzaNameMatchRequest(name1, name2, partner, record.getId(), entityType);
        try {
            String response = karzaApiService.callKarzaApi(karzaNameMatchRequest, null != entityType ? entityType : "entity");
            log.info("karza name match api response: {}", response);
            if (null != response) {
                KarzaResponseDto dmtResponseDTO = new ObjectMapper().readValue(response, new TypeReference<KarzaResponseDto>() {});
                if (null != dmtResponseDTO) {
                    karzaNameMatchRequest.setStatusCode(Integer.valueOf(dmtResponseDTO.getStatusCode()));
                    karzaNameMatchRequest.setRequestId(dmtResponseDTO.getRequestId());
                    karzaNameMatchRequest.setResponseData(response);
                    karzaNameMatchRequestRepository.save(karzaNameMatchRequest);
                    if (null != dmtResponseDTO.getResult() && null != dmtResponseDTO.getResult().getResult()) {
                        karzaNameMatchRequest.setScore(new BigDecimal(dmtResponseDTO.getResult().getScore()));
                        karzaNameMatchRequest.setResult(Boolean.valueOf(dmtResponseDTO.getResult().getResult()));
                        karzaNameMatchRequestRepository.save(karzaNameMatchRequest);
                        if (dmtResponseDTO.getResult().getResult().equalsIgnoreCase("True") && new BigDecimal(dmtResponseDTO.getResult().getScore()).compareTo(new BigDecimal(0.65)) > 0) {
                            record.nameVerificationStatus(NameVerificationStatusEnum.SUCCESS);
                        } else {
                            record.nameVerificationStatus(NameVerificationStatusEnum.FAIL);
                        }
                    }
                }
            }
        } catch (Exception e) {
            log.info("Exception: {}", e);
            record.nameVerificationStatus(NameVerificationStatusEnum.TIMEOUT);
        }
        accountVerificationRecordRepository.save(record);
    }


    // create Account Verification Record
        private AccountVerificationRecord createAccountVerificationRecord(Partner partner, String ownerType, Long ownerId, String accountNumber, String ifscCode, String nameToBeVerify, ChannelEnum channel, Boolean isNameVerification, BigDecimal fees, String pan) {
        AccountVerificationRecord record = new AccountVerificationRecord().accountNumber(accountNumber).ifscCode(ifscCode).channel(channel).ownerId(ownerId).ownerType(ownerType).partner(partner)
                .accountVerificationStatus(AccountVerificationStatusEnum.PENDING).nameToBeVerified(nameToBeVerify).nameVerificationStatus(isNameVerification ? NameVerificationStatusEnum.PENDING : null);
        record.setBankCode(ifscCode.substring(0,4));
        record.setPanNo(pan);
        if(null != fees) {
            record.setAccountVerificationfees(fees);
       //		record.setAccountVerificationMode(AccountVerificationModeEnum.valueOf(accountValidationMode));
        }
        return accountVerificationRecordRepository.save(record);
    }


    // PanAccount Api validation
    private AccountVerificationResponseDto panAccountVerification(String panNumber, AccountVerificationRecord record, String accountNumber, String ifscCode, Boolean isNameVerification, String nameToBeVerify, String ownerType, List<AccVerModeEnum> verificationModeList, Partner partner, String entityType) {
        if (StringUtils.isNotBlank(panNumber) && (null == verificationModeList || verificationModeList.contains(AccVerModeEnum.PAN_ACCOUNT_API))) {
            String bankCode = ifscCode.substring(0, 4);
            Optional<BankList> bankListInfo = bankListRepository.findByBankCodeAndIsPanAccountAccepted(bankCode, Boolean.TRUE);
            if(!bankListInfo.isPresent()) {
                log.info("BankList with IsPanAccountAccepted not present with bank code: {}", bankCode);
                accountVerificationRecordRepository.save(record.accountVerificationStatus(AccountVerificationStatusEnum.FAILED).accountVerificationMessage("Bank code not supported for PAN Account").accountVerificationMode(AccountVerificationModeEnum.PAN_ACCOUNT_API).accountVerificationId(null).verifiedAccountName(null));
                return new AccountVerificationResponseDto(record.getAccountVerificationStatus(), record.getAccountVerificationMode(), record.getNameVerificationStatus());
            }
            PANAccountApiRequest panAccountApiRequest = createPanApiRequest(record.getId(), ownerType, partner);
            try {
                String response = panAccountApiService.panAccountApi(accountNumber, ifscCode, panNumber, panAccountApiRequest);
                PanAccountApiResponsePayloadDto panAccountApiResponseDto = new ObjectMapper().readValue(response, PanAccountApiResponsePayloadDto.class);
                updatePanAccountApiRequest(panAccountApiRequest, panAccountApiResponseDto);
                if (panAccountApiResponseDto.getStatus().equalsIgnoreCase("S")) {
                    record.accountVerificationStatus(AccountVerificationStatusEnum.SUCCESS).accountVerificationMessage("PAN is linked with an account.").verifiedAccountName(panAccountApiResponseDto.getAccCustName()).accountVerificationMode(AccountVerificationModeEnum.PAN_ACCOUNT_API).accountVerificationId(panAccountApiRequest.getId());
                    accountVerificationRecordRepository.save(record);
                    if (isNameVerification) {
                        verifyName(nameToBeVerify, panAccountApiResponseDto.getAccCustName(), record, partner, entityType);
                    }
                    return new AccountVerificationResponseDto(record.getAccountVerificationStatus(), record.getAccountVerificationMode(), record.getNameVerificationStatus(), record.getVerifiedAccountName(), record.getId(), record.getAccountVerificationMessage()).panAccountApiResponseDto(panAccountApiResponseDto);
                } else if (panAccountApiResponseDto.getStatus().equalsIgnoreCase("F")) {
                    if (panAccountApiResponseDto.getErrCode().equalsIgnoreCase("PA")) {
                        record.accountVerificationStatus(AccountVerificationStatusEnum.FAILED).accountVerificationMessage("PAN/Account mapping validation failed").verifiedAccountName(panAccountApiResponseDto.getAccCustName()).accountVerificationMode(AccountVerificationModeEnum.PAN_ACCOUNT_API).accountVerificationId(panAccountApiRequest.getId());
                        accountVerificationRecordRepository.save(record);
                        return new AccountVerificationResponseDto(record.getAccountVerificationStatus(), record.getAccountVerificationMode(), record.getNameVerificationStatus(), "AV001", "PAN not linked with given account");
                    } else {
                        String timeoutMessage = "PAN/Account Timeout";
                        if (null != panAccountApiResponseDto && null != panAccountApiResponseDto.getStatusDesc()) {
                            timeoutMessage = panAccountApiResponseDto.getStatusDesc();
                        }
                        record.accountVerificationStatus(AccountVerificationStatusEnum.TIMEOUT).accountVerificationMessage(timeoutMessage).verifiedAccountName(panAccountApiResponseDto.getAccCustName()).accountVerificationMode(AccountVerificationModeEnum.PAN_ACCOUNT_API).accountVerificationId(panAccountApiRequest.getId());
                        accountVerificationRecordRepository.save(record);
                        return new AccountVerificationResponseDto(AccountVerificationStatusEnum.TIMEOUT, record.getAccountVerificationMode(), record.getNameVerificationStatus());
                    }
                }
            } catch (IOException e) {
                log.info("Timeout in Pan account api: {}", e);
                panAccountApiRequest.setStatusDescription("Timeout");
                panAccountApiRequest.setErrorCode("999");
                panAccountApiRequestRepository.save(panAccountApiRequest);
                record.accountVerificationStatus(AccountVerificationStatusEnum.TIMEOUT).accountVerificationMessage("PAN/Account Timeout").accountVerificationMode(AccountVerificationModeEnum.PAN_ACCOUNT_API).accountVerificationId(panAccountApiRequest.getId());
                accountVerificationRecordRepository.save(record);
                return new AccountVerificationResponseDto(AccountVerificationStatusEnum.TIMEOUT, record.getAccountVerificationMode(), record.getNameVerificationStatus());
            } catch (Exception e) {
                String[] exceptionMessage = e.getMessage().split(":");
                if (exceptionMessage.length == 2) {
                    panAccountApiRequest.setStatusDescription(exceptionMessage[0]);
                    panAccountApiRequest.setErrorCode(exceptionMessage[1]);
                    panAccountApiRequestRepository.save(panAccountApiRequest);
                }
                log.info("Exception: {} in Pan Account Verification", e);
            }
        }
        return null;
    }

    public String panAccountApi(String accNo, String ifsc, String pan, PANAccountApiRequest panAccountApiRequest) throws IOException, Exception {
        String requestJson = getPanRequestJson(accNo, ifsc, pan, panAccountApiRequest);
        String response = dataPowerUtil.postJsonWithDataPower(url, requestJson, 15, false);
        log.info("response for panAccountApi: {}", response);
        PanAccountApiResponseDto panAccountApiResponseDto = new ObjectMapper().readValue(response, PanAccountApiResponseDto.class);
        String responsePayloadJson = aes.decrypt(panAccountApiResponseDto.getPayload(), cipherKey);
        log.info("decrypted response payload for panAccountApi: {}", responsePayloadJson);
        return responsePayloadJson;
    }

    // Universal VPA Validation
  private AccountVerificationResponseDto universalVpaValidation(AccountVerificationRecord record,	String accountNumber, String ifscCode, Boolean isNameVerification, String nameToBeVerify,
                                                                  List<AccVerModeEnum> verificationModeList, Partner partner, String entityType) {
        if (null == verificationModeList || verificationModeList.contains(AccVerModeEnum.UNIVERSAL_VPA_VALIDATION)) {
            String bankCode = ifscCode.substring(0, 4);
            Optional<BankList> bankListInfo = bankListRepository.findByBankCodeAndUniversalVpaSupport(bankCode, Boolean.TRUE);
            if(!bankListInfo.isPresent()) {
                log.info("BankList with Universal VPA Support not present with bank code: {}", bankCode);
                accountVerificationRecordRepository.save(record.accountVerificationStatus(AccountVerificationStatusEnum.FAILED).accountVerificationMessage("Bank code not supported for Universal VPA Validation").accountVerificationMode(AccountVerificationModeEnum.UNIVERSAL_VPA_VALIDATION).accountVerificationId(null).verifiedAccountName(null));
                return new AccountVerificationResponseDto(record.getAccountVerificationStatus(), record.getAccountVerificationMode(), record.getNameVerificationStatus());
            }
            String vpa = accountNumber + "@" + ifscCode + ".ifsc.npci";
            VpaValidationApiRequest validationApiRequest = new VpaValidationApiRequest().ownerId(record.getId()).ownerType(VpaValidationApiRequestOwnerTypeEnum.ACCOUNT_VERIFICATION);
            vpaValidationApiRequestRepository.save(validationApiRequest);
            try {
                ValidateVpaResponseParameterDto responseDto = validateVpaApiService.validateVpaApi(vpa);
                validationApiRequest.merchantTxnId(responseDto.getPspRefNo());
                vpaValidationApiRequestRepository.save(validationApiRequest);
                if (null != responseDto && null != responseDto.getStatus() && responseDto.getStatus().equalsIgnoreCase("VE")) {
                    record.accountVerificationStatus(AccountVerificationStatusEnum.SUCCESS).accountVerificationMessage("Account verified through universal VPA.").verifiedAccountName(responseDto.getMaskName()).accountVerificationMode(AccountVerificationModeEnum.UNIVERSAL_VPA_VALIDATION).accountVerificationId(validationApiRequest.getId());
                    accountVerificationRecordRepository.save(record);
                    if (isNameVerification) {
                        verifyName(nameToBeVerify, responseDto.getMaskName(), record, partner, entityType);
                    }
                    return new AccountVerificationResponseDto(record.getAccountVerificationStatus(), record.getAccountVerificationMode(), record.getNameVerificationStatus(), record.getVerifiedAccountName(), record.getId(), record.getAccountVerificationMessage());
                } else {
                    String timeoutMessage = "Universal VPA Timeout";
                    if (null != responseDto && null != responseDto.getStatusDesc()) {
                        timeoutMessage = responseDto.getStatusDesc();
                    }
                    record.accountVerificationStatus(AccountVerificationStatusEnum.TIMEOUT).accountVerificationMessage(timeoutMessage).verifiedAccountName(responseDto.getMaskName()).accountVerificationMode(AccountVerificationModeEnum.UNIVERSAL_VPA_VALIDATION).accountVerificationId(validationApiRequest.getId());
                    accountVerificationRecordRepository.save(record);
                    return new AccountVerificationResponseDto(AccountVerificationStatusEnum.TIMEOUT, record.getAccountVerificationMode(), record.getNameVerificationStatus());
                }
            } catch (Exception e) {
                log.info("Exception: {}", e);
                record.accountVerificationStatus(AccountVerificationStatusEnum.TIMEOUT).accountVerificationMessage("Universal VPA Timeout").accountVerificationMode(AccountVerificationModeEnum.UNIVERSAL_VPA_VALIDATION).accountVerificationId(validationApiRequest.getId());
                accountVerificationRecordRepository.save(record);
                return new AccountVerificationResponseDto(AccountVerificationStatusEnum.TIMEOUT, record.getAccountVerificationMode(), record.getNameVerificationStatus());
            }
        }
        return null;
    }

    // PENNY_DROP_IMPS
        private AccountVerificationResponseDto pennyDropImps(AccountVerificationRecord record, String accountNumber, String ifscCode, Boolean isNameVerification, String nameToBeVerify,
                                                         List<AccVerModeEnum> verificationModeList, String entityType) {
        if (null == verificationModeList || verificationModeList.contains(AccVerModeEnum.PENNY_DROP_IMPS)) {
            try {
                String bankCode = ifscCode.substring(0, 4);
                Optional<BankList> bankListInfo = bankListRepository.findByBankCodeAndIsImpsAccepted(bankCode, Boolean.TRUE);
                if(!bankListInfo.isPresent()) {
                    log.info("BankList with IsImpsAccepted not present with bank code: {}", bankCode);
                    accountVerificationRecordRepository.save(record.accountVerificationStatus(AccountVerificationStatusEnum.FAILED).accountVerificationMessage("Bank code not supported for IMPS").accountVerificationMode(AccountVerificationModeEnum.PENNY_DROP_IMPS).accountVerificationId(null).verifiedAccountName(null));
                    return new AccountVerificationResponseDto(record.getAccountVerificationStatus(), record.getAccountVerificationMode(), record.getNameVerificationStatus());
                }
                ParameterManagement management = parameterManagementRepository.findByName(ParameterManagementEnum.PENNY_DROP_PARTNER_ID.name());
                Optional<Partner> partnerInfo = partnerRepository.findById(Long.valueOf(management.getValue()));
                if (partnerInfo.isPresent()) {
                    Partner partner = partnerInfo.get();
                    BigDecimal amount = new BigDecimal(1);
                    PartnerTransactions odLoadTransaction = null;
                    log.info("partner virtual account current balance {} and txn amount is {} and od facility is {}", partner.getActualBalance(), amount, partner.getPartnerSetup().getOdFacility());
                    if (partner.getActualBalance().compareTo(amount) < 0 && partner.getPartnerSetup().getOdFacility() && odBalance(partner, amount)) {
                        odLoadTransaction = odFacilityProcess(partner, amount);
                    }
                    VirtualSystemAccounts systemAccounts = virtualSystemAccountsRepository.findByAccountType(PartnerAccountTypeEnum.MW_IMPS_PAYABLE_POOL.getName()).get();

                    PartnerTransactions transactions = new PartnerTransactions();
                    transactions.txnDate(Instant.now()).partner(partner).virtualSystemAccounts(systemAccounts).amount(amount)
                            .txnRefNo(accountUtil.getPartnerTxnCounter("PARTNER")).txnStatus(TransactionStatus.SUCCESS).settlementStatus(SettlementStatus.PENDING)
                            .serviceConsumptionState(partner.getStateCode()).ownerType(VirtualOwnerType.PARTNER).ownerId(partner.getId()).transactionType(TransactionalTypeEnum.PENNY_DROP)
                            .field3(ifscCode + "|" + accountNumber);
                    if (null != odLoadTransaction) {
                        odLoadTransaction.setMerchantReferenceNumber(transactions.getTxnReferenceNumber());
                        partnerTransactionsRepository.save(odLoadTransaction);
                    }
                    Long partnerTxnId = virtualAccountEntryService.impsNeftTransfer(transactions);
                    log.info("partnerTxnId : {}", partnerTxnId);
                    transactions = partnerTransactionsRepository.findById(partnerTxnId).get();
                    log.info("transactions : {}", transactions);
                    String narration = "YESBANK";
                    MobilewareApisResponse mobilewareApisResponse = mobileWareService.synchronousP2A(transactions, narration, accountNumber, ifscCode);
                    if (null != mobilewareApisResponse && null != mobilewareApisResponse.getStatus() && "SUCCESS".equalsIgnoreCase(mobilewareApisResponse.getStatus()) && "00".equalsIgnoreCase(mobilewareApisResponse.getResponseCode())) {
                        transactions.setField1(mobilewareApisResponse.getStatus() + "|" + mobilewareApisResponse.getResponseCode() + "|" + mobilewareApisResponse.getResponseMsg());
                        transactions.setMerchantReferenceNumber(mobilewareApisResponse.getRrn());
                        transactions.setSettlementStatus(SettlementStatus.SETTLED);
                        transactions.setField4(mobilewareApisResponse.getBeneficiaryName());
                        partnerTransactionsRepository.save(transactions);
                        record.accountVerificationStatus(AccountVerificationStatusEnum.SUCCESS).accountVerificationMessage("Account verified through IMPS API.").verifiedAccountName(mobilewareApisResponse.getBeneficiaryName()).accountVerificationMode(AccountVerificationModeEnum.PENNY_DROP_IMPS).accountVerificationId(transactions.getId());
                        accountVerificationRecordRepository.save(record);
                        if (isNameVerification) {
                            verifyName(nameToBeVerify, mobilewareApisResponse.getBeneficiaryName(), record, partner, entityType);
                        }
                        return new AccountVerificationResponseDto(record.getAccountVerificationStatus(), record.getAccountVerificationMode(), record.getNameVerificationStatus(), record.getVerifiedAccountName(), record.getId(), record.getAccountVerificationMessage());
                    } else if (null != mobilewareApisResponse && null != mobilewareApisResponse.getStatus() && "FAILURE".equals(mobilewareApisResponse.getStatus()) && Arrays.asList("M1", "M3", "M4", "M5", "M0", "57").contains(mobilewareApisResponse.getResponseCode())) {
                        transactions.setField1(mobilewareApisResponse.getStatus() + "|" + mobilewareApisResponse.getResponseCode() + "|" + mobilewareApisResponse.getResponseMsg());
                        updatePartnerTxnForFailure(transactions, mobilewareApisResponse);
                        record.accountVerificationStatus(AccountVerificationStatusEnum.FAILED).accountVerificationMessage(mobilewareApisResponse.getResponseMsg()).verifiedAccountName(mobilewareApisResponse.getBeneficiaryName()).accountVerificationMode(AccountVerificationModeEnum.PENNY_DROP_IMPS).accountVerificationId(transactions.getId());
                        accountVerificationRecordRepository.save(record);
                        return new AccountVerificationResponseDto(AccountVerificationStatusEnum.FAILED, record.getAccountVerificationMode(), record.getNameVerificationStatus(), "AV002", "Account verification via Mobileware IMPS API failed");
                    } else if (null != mobilewareApisResponse && null != mobilewareApisResponse.getStatus() && Arrays.asList("PENDING", "FAILURE").contains(mobilewareApisResponse.getStatus())) {
                        transactions.setField1(mobilewareApisResponse.getStatus() + "|" + mobilewareApisResponse.getResponseCode() + "|" + mobilewareApisResponse.getResponseMsg());
                        if ("FAILURE".equals(mobilewareApisResponse.getStatus()))
                            updatePartnerTxnForFailure(transactions, mobilewareApisResponse);
                        if("PENDING".equals(mobilewareApisResponse.getStatus()) && "91".equals(mobilewareApisResponse.getResponseCode())) {
                            partnerTransactionsRepository.save(transactions.field1(mobilewareApisResponse.getStatus() + "|" + mobilewareApisResponse.getResponseCode() + "|" + mobilewareApisResponse.getResponseMsg()));
                        }
                        record.accountVerificationStatus(AccountVerificationStatusEnum.TIMEOUT).accountVerificationMode(AccountVerificationModeEnum.PENNY_DROP_IMPS).accountVerificationId(transactions.getId());
                        if(null != mobilewareApisResponse && null != mobilewareApisResponse.getResponseMsg()) {
                            record.accountVerificationMessage(mobilewareApisResponse.getResponseMsg());
                        }
                        accountVerificationRecordRepository.save(record);
                        return new AccountVerificationResponseDto(AccountVerificationStatusEnum.TIMEOUT, record.getAccountVerificationMode(), record.getNameVerificationStatus());
                    }
                }
            } catch (Exception e) {
                log.info("Exception: {}", e);
                record.accountVerificationStatus(AccountVerificationStatusEnum.TIMEOUT).accountVerificationMode(AccountVerificationModeEnum.PENNY_DROP_IMPS);
                accountVerificationRecordRepository.save(record);
                return new AccountVerificationResponseDto(AccountVerificationStatusEnum.TIMEOUT, record.getAccountVerificationMode(), record.getNameVerificationStatus());
            }
        }
        return null;
    }


       @Transactional(propagation = Propagation.REQUIRES_NEW)
    public Long impsNeftTransfer(PartnerTransactions transactions) {
        partnerTransactionsRepository.save(transactions);
        String txnSubType = getTxnSubType(transactions);
        String result = virtualAccountEntryRepository.partnerWithdraw(transactions.getAmount(), TransactionTypeEnum.PENNY_DROP.name(), transactions.getId(),
            transactions.getPartner().getVirtualAccount().getId(), transactions.getVirtualSystemAccounts().getVirtualAccount().getId(), transactions.getPartner().getId(), VirtualOwnerType.PARTNER.name(), txnSubType, transactions.getField5(), null);
        log.info("Withdraw result : {}", result);
        if ("Insufficient Balance".equals(result)) {
            throw new InsufficientBalanceException("Insufficient balance for fund transfer");
        } else if (!"success".equals(result)){
            throw new StoredProcedureException("Stored Procedure Failed");
        }
        return transactions.getId();
    }

    	public MobilewareApisResponse synchronousP2A(PartnerTransactions transactions, String narration, String accountNo, String ifscCode) throws Exception {
		log.info("Inside PartnerTransactions synchronousP2A mobileWare api");
		MobilewareApisResponse mobilewareApisResponse = new MobilewareApisResponse();
		MobileWareRequestDTO mobileWareRequestDTO = new MobileWareRequestDTO();
		try {
			mobileWareRequestDTO = this.getMobileWareRequest(transactions.getAmount(), transactions.getTxnReferenceNumber(), narration, accountNo, ifscCode,null,null);
			ObjectMapper mapper = new ObjectMapper();
			mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
			String jsonRequest = mapper.writeValueAsString(mobileWareRequestDTO);
			log.info("encrypted request for mobileWare api: {}", jsonRequest);
			Map<String, String> headers = new HashMap<String, String>();
			headers.put("Content-Type", "application/json");
			String url = baseUrl + "/imps-ws/transaction/sync/" + channelId +"/"+ "p2a";
			String response = httpServiceUtil.post(url, headers, jsonRequest, timeout);
			log.info("response for mobileWare api: {}", response);
			MobileWareResponseDTO mobileWareResponseDTO  = new ObjectMapper().readValue(response, MobileWareResponseDTO.class);
			String responsePayloadJson = mobileWare.decrypt(mobileWareResponseDTO.geteResp());
			log.info("decrypted response for mobileWare api: {} , and transaction referance number : {}", responsePayloadJson, transactions.getTxnReferenceNumber());
			mobilewareApisResponse = new ObjectMapper().readValue(responsePayloadJson, MobilewareApisResponse.class);

		} catch(ConnectTimeoutException cte) {
			log.error("Timeout exception in PartnerTransactions SynchronousP2A:", cte);
			transactions.setField1("999|Timeout");
			partnerTransactionsRepository.save(transactions);
		} catch(Exception ex) {
			log.error("Exception in PartnerTransactions SynchronousP2A:", ex);
		}
		return mobilewareApisResponse;
	}

    private MobileWareRequestDTO getMobileWareRequest(BigDecimal amount, String txnReferenceNumber, String narration, String accountNo, String ifscCode,String remName, String remMob) throws Exception {
		log.info("Inside mobile ware request generation txnRefernceNo {}", txnReferenceNumber);;
		MobileWareRequestDTO mobileWareRequestDTO = new MobileWareRequestDTO();
		MobilewareApisRequest mobilewareApisRequest = new MobilewareApisRequest(); 
		mobilewareApisRequest.setAmount(String.format("%.2f", amount));
		mobilewareApisRequest.setClientRefId(txnReferenceNumber);
		mobilewareApisRequest.setNarration(narration);
		mobilewareApisRequest.setToAccountNo(accountNo);
		mobilewareApisRequest.setToIFSC(ifscCode);
		mobilewareApisRequest.setRemitterName(remName);
		mobilewareApisRequest.setRemMobNo(remMob);
		String hashKey = mobileWare.generateHaskKey(String.format("%.2f", amount) + txnReferenceNumber + accountNo + ifscCode);
		log.info("hashkey {}", hashKey);
		mobilewareApisRequest.setHashKey(hashKey);
		log.info("request for mobileWare api: {}", mobilewareApisRequest);
		ObjectMapper mapper = new ObjectMapper();
		mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
		String json = mapper.writeValueAsString(mobilewareApisRequest);
		String encryptedString =  mobileWare.encrypt(json);
		mobileWareRequestDTO.seteReq(encryptedString);
		return mobileWareRequestDTO;
	}

    	public String decrypt(String message) throws Exception {
		String base64EncryptedString = "";
		try {
			MessageDigest md = MessageDigest.getInstance("SHA-256");
			byte[] digestOfPassword = md.digest(sercretKey.getBytes(StandardCharsets.UTF_8));
			byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
			byte[] iv = Arrays.copyOf(digestOfPassword, 16);
			SecretKey key = new SecretKeySpec(keyBytes, "AES");
			Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
			IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

			// For Decrypt
			cipher.init(Cipher.DECRYPT_MODE, key, ivParameterSpec);
			byte[] decordedValue = new Base64().decode(message.getBytes());
			byte[] buf = cipher.doFinal(decordedValue);
			base64EncryptedString = new String(buf);
		} catch (Exception nse) {
			throw new Exception("Invalid input String");
		}
		return base64EncryptedString;
	}



	public NsdlNameMatchResponse nsdlNameMatchProcess(String panFirstName, String panLastName, String nameOnCard, String nameToCompare, Partner partner, String ownerType, Long ownerId, Boolean isNameToCompareVerified, String type) throws Exception  {
		log.info("Nsdl Name Match Process Starts With panFirstName: {}, panLastName: {}, nameOnCard: {}, nameToCompare: {}", panFirstName, panLastName, nameOnCard, nameToCompare);
		nameToCompare = nameToCompare.toLowerCase();

		String[] nameToCompareArray = nameToCompare.split(" ");
		String nameToCompareTrimmed = nameToCompare.replaceAll("[., ]", "");
		if (StringUtils.isNotBlank(nameOnCard)) {
			nameOnCard = nameOnCard.toLowerCase();
			String nameOnCardTrimmed = nameOnCard.replaceAll("[., ]", "");
			if (nameToCompareTrimmed.contains(nameOnCardTrimmed)) {
				log.info("Match Case 1");
				return new NsdlNameMatchResponse(Boolean.TRUE, null,null);
			}
			if (isNameToCompareVerified) {
				if (StringUtils.isNotBlank(nameToCompareTrimmed) && nameOnCardTrimmed.contains(nameToCompareTrimmed)) {
					log.info("Match Case 2");
					return new NsdlNameMatchResponse(Boolean.TRUE, null,null);
				}
			}
			String[] nameOnCardArray = nameOnCard.split(" ");
			Arrays.sort(nameToCompareArray);
			Arrays.sort(nameOnCardArray);
			if (Arrays.equals(nameToCompareArray, nameOnCardArray)) {
				log.info("Match Case 3");
				return new NsdlNameMatchResponse(Boolean.TRUE, null,null);
			}
		}
		if (StringUtils.isNoneBlank(panFirstName, panLastName)) {
			if (nameToCompare.contains(panFirstName.toLowerCase()) && Arrays.stream(nameToCompareArray).anyMatch(panLastName.substring(0,1)::equalsIgnoreCase)) {
				log.info("Match Case 4");
				return new NsdlNameMatchResponse(Boolean.TRUE, null,null);
			}
			if (nameToCompare.contains(panLastName.toLowerCase()) && Arrays.stream(nameToCompareArray).anyMatch(panFirstName.substring(0,1)::equalsIgnoreCase)) {
				log.info("Match Case 5");
				return new NsdlNameMatchResponse(Boolean.TRUE, null,null);
			}
		}
		if (null != panFirstName && null != panLastName) {
			String panFirstNameTrimmed = panFirstName.replaceAll("[., ]", "").toLowerCase();
			String panLastNameTrimmed = panLastName.replaceAll("[., ]", "").toLowerCase();
			if (!StringUtils.isAllBlank(panFirstNameTrimmed,panLastNameTrimmed)) {
				if (nameToCompareTrimmed.contains(panFirstNameTrimmed) && nameToCompareTrimmed.contains(panLastNameTrimmed)) {
					log.info("Match Case 6");
					return new NsdlNameMatchResponse(Boolean.TRUE, null,null);
				}
				if (isNameToCompareVerified && StringUtils.isNotBlank(nameToCompareTrimmed) && panFirstNameTrimmed.concat(panLastNameTrimmed).contains(nameToCompareTrimmed)) {
					log.info("Match Case 7");
					return new NsdlNameMatchResponse(Boolean.TRUE, null,null);
				}
			}
		}
		KarzaNameMatchRequest karzaNameMatchRequest = null;
		if (StringUtils.isNotBlank(nameOnCard)) {
			karzaNameMatchRequest = createKarzaNameMatchRequest(nameOnCard, nameToCompare, partner, ownerType, ownerId);
		} else {
			karzaNameMatchRequest = createKarzaNameMatchRequest(panFirstName + " " + panLastName, nameToCompare, partner, ownerType, ownerId);
		}
		try {
		String response = karzaApiService.callKarzaApi(karzaNameMatchRequest, type);
		if (null != response) {
			KarzaResponseDto dmtResponseDTO = new ObjectMapper().readValue(response, KarzaResponseDto.class);
			if (null != dmtResponseDTO) {
				karzaNameMatchRequest.setStatusCode(StringUtils.isNotBlank(dmtResponseDTO.getStatusCode()) ? Integer.valueOf(dmtResponseDTO.getStatusCode())
						: (StringUtils.isNotBlank(dmtResponseDTO.getStatus()) ? Integer.valueOf(dmtResponseDTO.getStatus()) : null));
				karzaNameMatchRequest.setResponseData(response);
				karzaNameMatchRequest.setRequestId(dmtResponseDTO.getRequestId());
				karzaNameMatchRequest.setEntityType(type);
				karzaNameMatchRequestRepository.save(karzaNameMatchRequest);
				if (null != dmtResponseDTO.getResult()) {
					karzaNameMatchRequest.setScore(new BigDecimal(dmtResponseDTO.getResult().getScore()));
					karzaNameMatchRequest.setResult(Boolean.valueOf(dmtResponseDTO.getResult().getResult()));
					karzaNameMatchRequestRepository.save(karzaNameMatchRequest);
					if (dmtResponseDTO.getResult().getResult().equalsIgnoreCase("True")
							&& new BigDecimal(dmtResponseDTO.getResult().getScore()).compareTo(new BigDecimal(0.65)) > 0) {
						return new NsdlNameMatchResponse(Boolean.TRUE, new BigDecimal(dmtResponseDTO.getResult().getScore()),null);
					} else {
						return new NsdlNameMatchResponse(Boolean.FALSE, new BigDecimal(dmtResponseDTO.getResult().getScore()),null);
					}
				}
			}
		}} catch (org.apache.http.conn.ConnectTimeoutException r) {
			log.info("ConnectTimeoutException cought {}", r.getMessage());
			karzaNameMatchRequest.setStatusCode(999);
			karzaNameMatchRequest.setResponseData("Timeout");
			karzaNameMatchRequest.setEntityType(type);
			karzaNameMatchRequestRepository.save(karzaNameMatchRequest);
//			return new NsdlNameMatchResponse(Boolean.FALSE, null);
            return new NsdlNameMatchResponse(Boolean.FALSE, null, karzaNameMatchRequest.getResponseData());
		} catch (ClientProtocolException p) {
			log.info("ClientProtocolException cought {}", p.getMessage());
			String statusCode = p.getMessage().substring(p.getMessage().length() - 3);
			karzaNameMatchRequest.setStatusCode(Integer.valueOf(statusCode));
			karzaNameMatchRequest.setEntityType(type);
			karzaNameMatchRequestRepository.save(karzaNameMatchRequest);
			return new NsdlNameMatchResponse(Boolean.FALSE, null,null);
		}
		return new NsdlNameMatchResponse(Boolean.FALSE, null,null);
	}

    private KarzaNameMatchRequest createKarzaNameMatchRequest(String nameOnCard, String nameToCompare, Partner partner, String ownerType, Long ownerId) {
		KarzaNameMatchRequest karzaNameMatchRequest = new KarzaNameMatchRequest();
		karzaNameMatchRequest.setName1(nameOnCard);
		karzaNameMatchRequest.setName2(nameToCompare);
		karzaNameMatchRequest.setOwnerType(OwnerTypeEnum.valueOf(ownerType));
		karzaNameMatchRequest.setOwnerId(ownerId);
		karzaNameMatchRequest.setPartner(partner);
		return karzaNameMatchRequestRepository.save(karzaNameMatchRequest);
	}

    public String callKarzaApi(KarzaNameMatchRequest karzaNameMatchRequest, String type) throws Exception {
        String requestJson = getRequestJson(karzaNameMatchRequest, type);
        Map<String, String> headers = new HashMap<>();
        headers.put("x-karza-key", xKarzaKey);
        headers.put("Content-Type", "application/json");
        log.info("Request To karza with Request {}", requestJson);
        String response = httpServiceUtil.post(url, headers, requestJson, 30);
        log.info("Response from karza with Response {}", response);
		return response;
    }

	private String getRequestJson(KarzaNameMatchRequest karzaNameMatchRequest, String type) throws JSONException {
		return new JSONObject().put("name1", karzaNameMatchRequest.getName1()).put("name2", karzaNameMatchRequest.getName2()).put("type", type).put("preset", "G")
				.put("allowPartialMatch", true).toString();
	}

     public String post(final String url, Map<String, String> headers, final String requestBodyJson, int timeout) throws ClientProtocolException, IOException {
        log.info("posting request for url :{} with headers :{},with requestBody: {}", url, headers, requestBodyJson);
        HttpPost httpPost = new HttpPost(url);
        StringEntity entity = new StringEntity(requestBodyJson);
        httpPost.setEntity(entity);
        for (String key : headers.keySet()) {
            httpPost.setHeader(key, headers.get(key));
        }
        // creating auditLogMap to store api log fields
        HashMap<String, String> auditLogMap = new HashMap<>();
        auditLogMap.put(ApiAuditLog.IN_TIME, Instant.now().toString());
        String clientIp = null;
        if (null != RequestContextHolder.getRequestAttributes()) {
        	HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        	if (null != request) {
        		clientIp = RandomUtil.getClientIp(request);
        	}
        }
        // printBeforeAudit  
        ApiAuditLog.printBeforeAuditLogFor3rdParty(auditLogMap, requestBodyJson, url, clientIp, ApiAuditLogChannel.THIRD_PARTY.name());
        
        RequestConfig config = RequestConfig.custom().setConnectTimeout(timeout * 1000).setConnectionRequestTimeout(timeout * 1000).setSocketTimeout(timeout * 1000).build();
        CloseableHttpClient client = HttpClients.custom().setDefaultRequestConfig(config).build();
        try {
            ResponseHandler<String> responseHandler = response -> {
                int status = response.getStatusLine().getStatusCode();
                if (status >= 200 && status < 300) {
                    HttpEntity responseEntity = response.getEntity();
                    return responseEntity != null ? EntityUtils.toString(responseEntity) : null;
                } else {
                    log.error("response status for request url :{} is :{}", url, status);
                    log.info("response: {}", EntityUtils.toString(response.getEntity()));
                    // printAfterAudit  
            		ApiAuditLog.printAfterAuditLogFor3rdParty(auditLogMap, null, String.valueOf(status));
                    throw new ClientProtocolException("Unexpected response status:{}" + status);
                }
            };
            String response = client.execute(httpPost, responseHandler);
            log.info("response for request url :{} is :{}", url, response);
        	// printAfterAudit  
        	ApiAuditLog.printAfterAuditLogFor3rdParty(auditLogMap, response, String.valueOf(HttpStatus.OK.value()));
            return response;
        } finally {
            client.close();
        }
    }