
YPP-14770 API CLIENT_LIMIT_TRANSFER_TO_SOURCE
============================================

private PartnerApisResponse fundTransferToSource(PartnerApisRequest partnerApisRequest, Partner partner) {
    	log.info("request to fund transfer to source {} for partner {} ", partnerApisRequest , partner.getId());
    	try {
    		//Check for missing parameter
	    	if(StringUtils.isAnyBlank(partnerApisRequest.getPartnerReferenceNo(), partnerApisRequest.getP1(),partnerApisRequest.getP2(),partnerApisRequest.getP3(),
	    			partnerApisRequest.getP4(),partnerApisRequest.getP5())) {
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "P006")));
	    	}
	    	if (!partnerApisRequest.getPartnerReferenceNo().matches("[a-zA-Z0-9]+")) {
				log.info("Invalid Partner Reference Number {}",partnerApisRequest.getPartnerReferenceNo() );
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA068")));
			}
	    	//Check for invalid IFSC code
	    	if(!RandomUtil.isValidIFSCode(partnerApisRequest.getP4())) {
	    		log.info("Invalid source account IFSC {}",partnerApisRequest.getP4());
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA012")));
    		}
	    	//Check for client identifier presence
	    	Optional<PartnerClient> partnerClientOpt = this.partnerClientRepository.findByClientIdentifierAndPartnerId(partnerApisRequest.getP1(), partner.getId());
	    	if(!partnerClientOpt.isPresent()) {
	    		log.info("Invalid client identifier {}", partnerApisRequest.getP1());
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA005")));
	    	}
            PartnerClient partnerClient = partnerClientOpt.get();
	    	//Check fo client active or not
	    	if(!Status.ACTIVE.equals(partnerClient.getStatus())) {
	    		log.info("Client inactive {}", partnerClient.getStatus());
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA029")));
	    	}

	    	 if(partnerClient.getIsSuspended() == Boolean.TRUE) {
            	 log.info("Client is suspended {}", partnerClient.getIsSuspended());
            	 return new PartnerApisResponse(DAErrorCode.CLIENT_IS_SUSPENDED);
            }

	    	//Check for source account
            Optional<PartnerClientSourceAccount> sourceAccountOpt = this.partnerClientSourceAccountRepository.findByPartnerClientIdAndAccountNumber(partnerClient.getId(), partnerApisRequest.getP3());
	    	if(!sourceAccountOpt.isPresent()) {
	    		log.info("Invalid source account no {}",partnerApisRequest.getP3());
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA011")));
	    	}
	    	//Check for source account active or not
            PartnerClientSourceAccount sourceAccount = sourceAccountOpt.get();
            if(!Status.ACTIVE.equals(sourceAccount.getStatus())) {
	    		log.info("Inactive source account {}", partnerClient.getStatus());
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA043")));
	    	}
	    	//Check for mismatch IFSC code
	    	if(!partnerApisRequest.getP4().equals(sourceAccount.getIfscCode())) {
	    		log.info("Mismatch source account  {} and IFSC {}",partnerApisRequest.getP3(),partnerApisRequest.getP4());
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA042")));
	    	}
	    	//Check for partner reference number
	    	Optional<LimitReconTransactions> limitReconTransaction = this.limitReconTransactionsRepository.findByPartnerReferenceNumberAndPartnerId(partnerApisRequest.getPartnerReferenceNo(),partner.getId());
	    	if(limitReconTransaction.isPresent()) {
	    		log.info("Invalid partner reference number {}",partnerApisRequest.getPartnerReferenceNo());
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA023")));
	    	}
	    	partnerApisRequest.setP5(partnerApisRequest.getP5().toUpperCase());
	    	//Check for payment mode exist or not
	    	if(!paymentMode.contains(partnerApisRequest.getP5())) {
	    		log.info("Invalid payment mode {}", partnerApisRequest.getP5());
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA036")));
	    	}
	    	//Check for amount greater than 0
	    	BigDecimal amount;
	    	try {
	    		amount = new BigDecimal(partnerApisRequest.getP2());
	    		if(!RandomUtil.validateAmount(amount)) {
	    			log.info("Invalid amount {}" , partnerApisRequest.getP2());
		    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA038")));
	    		}
	    	} catch(Exception e) {
	    		log.info("Invalid amount {}", partnerApisRequest.getP2());
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA038")));
	    	}
	    	//Check for valid amount
	    	boolean inValidAmount = false;
	    	switch(partnerApisRequest.getP5()) {
	    		case "UPI":
	    			if(amount.compareTo(new BigDecimal(100000)) > 0) {
	    				inValidAmount = true;
	    			}
	    			break;
	    		case "IMPS":
	    			ParameterManagement parameterManagement = parameterManagementRepository.findByName(ParameterManagementEnum.IMPS_TXN_AMT_LIMIT.name());
					BigDecimal impsTxnAmtLimit = new BigDecimal(parameterManagement.getValue());
	    			if(amount.compareTo(impsTxnAmtLimit) > 0) {
	    				inValidAmount = true;
	    			}
	    			break;
	    		case "RTGS":
		    		if(amount.compareTo(new BigDecimal(200000)) <= 0) {
		    			inValidAmount = true;
		    		}
		    		break;
	    		default:
	    			inValidAmount = false;
	    	}

	    	if(inValidAmount) {
	    		log.info("Invalid amount for payment mode {}",partnerApisRequest.getP5() );
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA039")));
	    	}
	    	//Check for sufficient balance present or not
	    	if(amount.compareTo(partnerClient.getActualBalance()) > 0) {
	    		log.info("Request amount {} and current balance {}", amount, partnerClient.getActualBalance());
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA040")));
	    	}
	    	if(amount.compareTo(sourceAccount.getActualBalance()) > 0) {
	    		log.info("Request amount {} and source account balance {}", amount, sourceAccount.getActualBalance());
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA047")));
	    	}
	    	LimitSystemAccount systemAccounts = null;
	    	BigDecimal fee = BigDecimal.ZERO;
	    	BigDecimal serviceCharge = BigDecimal.ZERO;
            PartnerDASetup partnerDASetup = partnerDASetupRepository.findByPartnerId(partner.getId()).get();
	    	switch(partnerApisRequest.getP5()) {
	    		case "IMPS":
                    systemAccounts = limitSystemAccountRepository.findByAccountType(AccountTypeEnum.IMPS_PAYABLE_POOL.getName());
                    fee = partnerDASetup.getImpsFee(amount);
                	serviceCharge = accountUtil.getServiceCharge(ServiceTypeEnum.IMPS, ChannelEnum.FT3, amount);
	    			break;
	    		case "NEFT":
                    systemAccounts = limitSystemAccountRepository.findByAccountType(AccountTypeEnum.NEFT_PAYABLE_POOL.getName());
                    fee = partnerDASetup.getNeftFlatFee();
                    serviceCharge = accountUtil.getServiceCharge(ServiceTypeEnum.NEFT, ChannelEnum.FT3, amount);
	    			break;
	    		case "RTGS":
                    systemAccounts = limitSystemAccountRepository.findByAccountType(AccountTypeEnum.RTGS_PAYABLE_POOL.getName());
                    fee = partnerDASetup.getRtgsFlatFee();
                    serviceCharge = accountUtil.getServiceCharge(ServiceTypeEnum.RTGS, ChannelEnum.FT3, amount);
	    			break;
	    	}
            LimitReconTransactions transaction = new LimitReconTransactions().limitSystemAccount(systemAccounts).amount(amount)
                                .txnStatus(TransactionStatus.SUCCESS).settlementStatus(SettlementStatus.PENDING).field3(sourceAccount.getIfscCode()+"|"+sourceAccount.getAccountNumber()+ "|" + sourceAccount.getAccountName())
                                .partnerReferenceNumber(partnerApisRequest.getPartnerReferenceNo()).fees(fee).feesGst(accountUtil.getGst(fee))
                                .txnRefNo(accountUtil.getTxnCounter("PARTNER_CLIENT")).partner(partner).transactionType(TransactionableTypeEnum.LIMIT_SOURCE_TRANSFER)
                                .ownerType(LimitOwnerType.PARTNER_CLIENT).ownerId(partnerClient.getId()).mobileNumber(partnerClient.getMobileNumber());
            transaction.setServiceCharge(serviceCharge);
            limitAccountEntryService.fundTransferToSource(transaction, partnerClient, sourceAccount);
	    	//TODO
	    	neftImpsService.bankTransfer(transaction, partnerApisRequest.getP5(), sourceAccount.getAccountName(), Boolean.FALSE);
            if (transaction.getSettlementStatus().equals(SettlementStatus.PENDING)) {
                //Success Response
                PartnerApisResponse partnerApisResponse = new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "00")));
                partnerApisResponse.setStatus("SUCCESS");
                partnerApisResponse.setPartnerReferenceNumber(partnerApisRequest.getPartnerReferenceNo());
                partnerApisResponse.setYppTxnReferenceNumber(transaction.getTxnReferenceNumber());
                return partnerApisResponse;
            } else {
	    		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA041")));
            }

    	} catch(Exception ex) {
    		log.error("Exception in transfer funds to source: ", ex);
   		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(CP_CLIENT_LIMIT_TRANSFER_TO_SOURCE, "YPP", "", "DCA041")));
    	}
    }

	public void fundTransferToSource(LimitReconTransactions transaction, PartnerClient partnerClient, PartnerClientSourceAccount sourceAccount) {
		transaction = limitReconTransactionsRepository.save(transaction);
        String txnSubType = getTxnSubType(transaction);
        String result = limitAccountEntryRepository.clientToSource(transaction.getAmount(), TransactionableTypeEnum.LIMIT_SOURCE_TRANSFER.toString(), transaction.getId(), partnerClient.getLimitAccount().getId(), transaction.getLimitSystemAccount().getLimitAccount().getId(), transaction.getOwnerId(), transaction.getOwnerType().name(), txnSubType);
        if ("Insufficient Balance".equals(result)) {
            throw new InsufficientBalanceException("No balance");
        } else if (!"success".equals(result)) {
            throw new StoredProcedureException("FT to Source Account Exception");
        }
        sourceAccount.setAmountTransferredBack(sourceAccount.getAmountTransferredBack().add(transaction.getAmount()));
        sourceAccountRepository.save(sourceAccount);
    }

    public void bankTransfer(LimitReconTransactions transactions, String transferType, String creditorName, Boolean isPartnerDrivenNarration) {
    	try {
    	    DomesticPaymentsRequestDTO requestDTO = getDomesticPaymentsRequestDto(transactions, transactions.getPartner(), transactions.getAmount(), transferType, creditorName, isPartnerDrivenNarration);
    		ObjectMapper mapper = new ObjectMapper();
    		mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    		String json = mapper.writeValueAsString(requestDTO);
    		String response = dataPowerUtil.postJsonWithDataPower(domesticPaymenturl, json, Integer.parseInt(domesticPaymentsTimeout),true);
    		JSONObject responseJson = new JSONObject(response);
    		DomesticPaymentResponseDTO responseDTO = mapper.readValue(responseJson.toString(), DomesticPaymentResponseDTO.class);
            DomesticPaymentsDataDTO paymentsDataDTO = responseDTO.getData();
            if (paymentsDataDTO != null) {
                if (null != paymentsDataDTO.getStatus() && paymentsDataDTO.getStatus().equalsIgnoreCase("Received")) {
                    transactions.setField1(paymentsDataDTO.getStatus() + "|" + paymentsDataDTO.getTransactionIdentification());
                    if(null != paymentsDataDTO.getInitiation()) {
                        transactions.setMerchantReferenceNumber(paymentsDataDTO.getInitiation().getEndToEndIdentification());
                     }
                    limitReconTransactionsRepository.save(transactions);
                } else if (null != paymentsDataDTO.getStatus() && paymentsDataDTO.getStatus().equalsIgnoreCase("Failed")) {
                    limitAccountEntryService.reversal(transactions, TransactionableTypeEnum.AUTO_REVERSAL);
                    transactions.settlementStatus(SettlementStatus.REVERSED).isIgnored(Boolean.TRUE).transactionRemarks("Transaction not accepted");
                    if(null != paymentsDataDTO.getInitiation()) {
                        transactions.setMerchantReferenceNumber(paymentsDataDTO.getInitiation().getEndToEndIdentification());
                     }
                    MetaResponseDTO metaDTO = responseDTO.getMeta();
                    if (null != metaDTO) {
                        String field1 = paymentsDataDTO.getStatus() + "|" + metaDTO.getErrorCode() + "|" + metaDTO.getErrorSeverity();
                        transactions.setField1(StringUtils.substring(field1, 0, 254));
                        transactions.failureCode(metaDTO.getErrorCode()).failureMessage(metaDTO.getErrorSeverity());
                    }
                    limitReconTransactionsRepository.save(transactions);
                }
            }
    	} catch (InterruptedException | ConnectTimeoutException | SocketTimeoutException e) {
    		log.error("Timeout Exception ", e);
    		transactions.setField1("999|Timeout");
    		limitReconTransactionsRepository.save(transactions);
    	} catch (Exception ex) {
    		log.error("Exception ", ex);
    	}
    }

    public LimitReconTransactions reversal(LimitReconTransactions transactions, TransactionableTypeEnum transactionType) {
        List<LimitAccountEntry> lAccountEntryList = limitAccountEntryRepository.findByLimitReconTransactionsId(transactions.getId());
        log.info("LAE List size {} for txn id {}", lAccountEntryList.size(), transactions.getId());
        for (LimitAccountEntry accountEntry : lAccountEntryList) {
            BigDecimal amount = accountEntry.getAmount();
            List<LimitAccountTransactions> lAccountTransactionList = limitAccountTransactionsRepository.findByLimitAccountEntryId(accountEntry.getId());
            log.info("Limit Account Transaction size {} for LAE id {}", lAccountTransactionList.size(), accountEntry.getId());
            Long credit = null;
            Long debit = null;
            for (LimitAccountTransactions accountTransaction : lAccountTransactionList) {
                log.info("LAT id {}", accountTransaction.getId());
                if (AccountTransactionType.CREDIT.name().equals(accountTransaction.getAccountEntryType()))
                    debit = accountTransaction.getLimitAccount().getId();
                else
                    credit = accountTransaction.getLimitAccount().getId();
            }
            log.info("Credit id {} and debit id {}", credit, debit);
            boolean isSameMonth = transactions.getCreatedDate().atZone(ZoneId.of("Asia/Kolkata")).toLocalDateTime().getMonth().equals(accountEntry.getCreatedDate().atZone(ZoneId.of("Asia/Kolkata")).toLocalDateTime().getMonth());
            String txnRefNumber = null;
            String narration = null;
            
            if(LimitOwnerType.PARTNER_CONSUMER.equals(transactions.getOwnerType())) {
        		String poolAlias = "";
        		if (transactions != null && !StringUtils.isEmpty(transactions.getLimitSystemAccount().getPoolAlias())){
        			poolAlias = StringUtils.defaultString(transactions.getLimitSystemAccount().getPoolAlias());
        		}
    			narration = "Reversal of Rs. " + amount +" credited against " + poolAlias + " transaction done on " + DateUtil.convertDateToIST(transactions.getTxnDate(), "dd-MM-yyyy HH:mm:ss")+".";
    			txnRefNumber = transactions.getTxnReferenceNumber();
            }
            String result = limitAccountEntryRepository.daReversal(amount, transactionType.name(), transactions.getId(), credit, debit, transactions.getOwnerId(), transactions.getOwnerType().name(), isSameMonth, txnRefNumber, narration);
            log.info("Stored Procedure result : {}", result);
            if ("already reversed".equals(result)) {
                throw new StoredProcedureException("Transaction already reversed");
            } else if (!"success".equals(result)) {
                throw new StoredProcedureException("Stored Procedure Failed");
            }
            if (accountEntry.getTransactionType().equals(TransactionableTypeEnum.LIMIT_SOURCE_TRANSFER.name())) {
                String[] accountDetails = transactions.getField3().split("\\|");
                PartnerClientSourceAccount sourceAccount = sourceAccountRepository.findByPartnerClientIdAndAccountNumberAndIfscCode(transactions.getOwnerId(), accountDetails[1], accountDetails[0]).get();
                sourceAccount.setAmountTransferredBack(sourceAccount.getAmountTransferredBack().subtract(transactions.getAmount()));
                sourceAccountRepository.save(sourceAccount);
            }
        }
        transactions.settlementStatus(SettlementStatus.REVERSED).isIgnored(Boolean.TRUE).thirdPartyStatus(ThirdPartyStatus.FAIL);
        return limitReconTransactionsRepository.save(transactions);
    }
