
YPP-14781 API DCA_FUND_TRANSFER
====================================

private PartnerApisResponse fundTransfer(PartnerApisRequest partnerApisRequest, Partner partner) {
    	log.info("request to fund transfer: {} : " + partnerApisRequest);
    	try {
    		//Check for missing parameter
	    	if(StringUtils.isAnyBlank(partnerApisRequest.getPartnerReferenceNo(), partnerApisRequest.getP1(), partnerApisRequest.getP2(),partnerApisRequest.getP6(),partnerApisRequest.getP7())) {
	    		log.info("Parameter missing");
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "P006")));
	    	}
	    	if (!partnerApisRequest.getPartnerReferenceNo().matches("[a-zA-Z0-9]+")) {
				log.info("Invalid Partner Reference Number {}",partnerApisRequest.getPartnerReferenceNo() );
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA068")));
			}
	    	if (StringUtils.isNotBlank(partnerApisRequest.getP8()) && !partnerApisRequest.getP8().matches("[a-zA-Z0-9 ]{1,50}")) {
				log.info("Invalid remarks: {}",partnerApisRequest.getP8());
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA074")));
			}
	    	partnerApisRequest.setP6(partnerApisRequest.getP6().toUpperCase());
	    	//Check for payment mode exist or not
	    	if(!paymentMode.contains(partnerApisRequest.getP6())) {
	    		log.info("Invalid payment mode {}", partnerApisRequest.getP6());
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA036")));
	    	}

	    	if(partnerApisRequest.getP6().equals("UPI")) {
	    		if(StringUtils.isAnyBlank(partnerApisRequest.getP5())) {
		      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "P006")));
	    		}
	    	} else {
	    		if(StringUtils.isAnyBlank(partnerApisRequest.getP3(), partnerApisRequest.getP4())) {
		      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "P006")));
	    		}
	    		//Check for invalid IFSC code
		    	if(!RandomUtil.isValidIFSCode(partnerApisRequest.getP4())) {
		    		log.info("Invalid source account IFSC {}", partnerApisRequest.getP4());
		      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA012")));
	    		}
	    	}
	    	PartnerDASetup partnerDASetup = partnerDASetupRepository.findByPartnerId(partner.getId()).get();
	    	Boolean isPurposePresent = StringUtils.isNoneBlank(partnerDASetup.getAllowedPayoutPurposes());
			if (isPurposePresent) {
				if (StringUtils.isBlank(partnerApisRequest.getP9())) {
					log.info("purpuse missing");
		      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "P006")));
				}
				if (!partnerApisRequest.getP9().matches("[a-zA-Z0-9 _]+")) {
					log.info("Invalid Purpose {}",partnerApisRequest.getP9());
		      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA080")));
				}
				List<String> purposes = Arrays.asList(partnerDASetup.getAllowedPayoutPurposes().split(","));
				if (!purposes.contains(partnerApisRequest.getP9())) {
					log.info("Invalid Purpose {} for config Id {} with purposes {}", partnerApisRequest.getP9(), partnerDASetup.getId(), partnerDASetup.getAllowedPayoutPurposes());
		      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA080")));
				}
			}
			if ("IMPS".equalsIgnoreCase(partnerApisRequest.getP6()) && StringUtils.isNotBlank(partnerApisRequest.getP4())) {
				String bankCode = partnerApisRequest.getP4().substring(0, 4);
				Optional<BankList> bankListInfo = bankListRepository.findByBankCodeAndIsImpsAccepted(bankCode, Boolean.TRUE);
				if(!bankListInfo.isPresent()) {
					log.info("BankList with IsImpsAccepted not present with bank code: {}", bankCode);
					return new PartnerApisResponse(DAErrorCode.IMPS_NOT_SUPPORTED_FOR_BENEFICIARY_BANK);
				}
			}
			//Check for valid amount
	    	if(partnerApisRequest.getP6().equals("RTGS") && !partnerDASetup.getEnableRtgsMode()) {
	    		log.info("RTGS mode not allowed for partner setup :{}", partnerDASetup.getId());
	    		return new PartnerApisResponse(DAErrorCode.RTGS_MODE_NOT_ALLOWED);
	    	}
	    	//Check for client identifier presence
	    	Optional<PartnerClient> partnerClientOpt = this.partnerClientRepository.findByClientIdentifierAndPartnerId(partnerApisRequest.getP1(), partner.getId());
	    	if(!partnerClientOpt.isPresent()) {
	    		log.info("Invalid client identifier {}",partnerApisRequest.getP1());
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA005")));
	    	}
	    	if(PartnerClientPurposeEnum.TRADE.equals(partnerClientOpt.get().getPurpose())){
				log.info("client is onboarded for {}", partnerClientOpt.get().getPurpose());
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA057")));
			}
	    	//Check fo client active or not
            PartnerClient partnerClient = partnerClientOpt.get();
            if(!Status.ACTIVE.equals(partnerClient.getStatus())) {
	    		log.info("Client inactive {}", partnerClient.getStatus());
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA029")));
	    	}
            if(partnerClient.getIsSuspended() == Boolean.TRUE) {
           	 log.info("Client is suspended {}", partnerClient.getIsSuspended());
           	 return new PartnerApisResponse(DAErrorCode.CLIENT_IS_SUSPENDED);
           }
	    	//Check for partner reference number
	    	Optional<LimitReconTransactions> limitReconTransaction = this.limitReconTransactionsRepository.findByPartnerReferenceNumberAndPartnerId(partnerApisRequest.getPartnerReferenceNo(),partner.getId());
	    	if(limitReconTransaction.isPresent()) {
	    		log.info("Invalid partner reference number {}", partnerApisRequest.getPartnerReferenceNo());
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA023")));
	    	}
	    	//Check for amount greater than 0
	    	BigDecimal amount;
	    	try {
	    		amount = new BigDecimal(partnerApisRequest.getP2());
	    		if(!RandomUtil.validateAmount(amount)) {
	    			log.info("Invalid amount {}" , partnerApisRequest.getP2());
		      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA038")));
	    		}
	    	} catch(Exception e) {
	    		log.info("Invalid amount {}" , partnerApisRequest.getP2());
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA038")));
	    	}

	    	boolean inValidAmount = false;
	    	switch(partnerApisRequest.getP6()) {
	    		case "UPI":
	    			if(amount.compareTo(new BigDecimal(100000)) > 0) {
	    				inValidAmount = true;
	    			}
	    			break;
	    		case "IMPS":
	    			ParameterManagement parameterManagement = parameterManagementRepository.findByName(ParameterManagementEnum.IMPS_TXN_AMT_LIMIT.name());
					BigDecimal impsTxnAmtLimit = new BigDecimal(parameterManagement.getValue());
	    			if(amount.compareTo(impsTxnAmtLimit) > 0) {
	    				inValidAmount = true;
	    			}
	    			break;
	    		case "RTGS":
		    		if(amount.compareTo(new BigDecimal(200000)) <= 0) {
		    			inValidAmount = true;
		    		}
		    		break;
	    		default:
	    			inValidAmount = false;
	    	}

	    	if(inValidAmount) {
	    		log.info("Invalid payment mode {}" , partnerApisRequest.getP2());
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA039")));
	    	}
	    	//Check for sufficient balance present or not
	    	if(amount.compareTo(partnerClient.getActualBalance()) > 0) {
	    		log.info("Insufficient Amount  {} Current balance {}", amount , partnerClient.getActualBalance());
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA040")));
	    	}
	    	String accountHolderName = partnerApisRequest.getP7();
	    	if(partnerApisRequest.getP7().length() > 30) {
	    		accountHolderName = StringUtils.abbreviate(partnerApisRequest.getP7(), 30);
	    	}
	    	LimitSystemAccount systemAccounts = null;
	    	String field3 = null;
	    	BigDecimal fee = BigDecimal.ZERO;
	    	BigDecimal serviceCharge = BigDecimal.ZERO;
	    	switch(partnerApisRequest.getP6()) {
	    		case "IMPS":
                    if(ImpsPayoutsChannelEnum.MOBILEWARE.equals(partnerDASetup.getImpsChannel())) {
    	    			systemAccounts = limitSystemAccountRepository.findByAccountType(AccountTypeEnum.MW_IMPS_PAYABLE_POOL.getName());
    	    			serviceCharge = accountUtil.getServiceCharge(ServiceTypeEnum.IMPS, ChannelEnum.MOBILEWARE, amount);
    	    		} else {
    	    			systemAccounts = limitSystemAccountRepository.findByAccountType(AccountTypeEnum.IMPS_PAYABLE_POOL.getName());
    	    			serviceCharge = accountUtil.getServiceCharge(ServiceTypeEnum.IMPS, ChannelEnum.FT3, amount);
    	    		}
                    field3 = partnerApisRequest.getP4()+"|"+partnerApisRequest.getP3()+"|"+accountHolderName;
                    fee = partnerDASetup.getImpsFee(amount);
	    			break;
	    		case "NEFT":
                    systemAccounts = limitSystemAccountRepository.findByAccountType(AccountTypeEnum.NEFT_PAYABLE_POOL.getName());
                    field3 = partnerApisRequest.getP4()+"|"+partnerApisRequest.getP3()+"|"+accountHolderName;
                    fee = partnerDASetup.getNeftFlatFee();
                    serviceCharge = accountUtil.getServiceCharge(ServiceTypeEnum.NEFT, ChannelEnum.FT3, amount);
	    			break;
	    		case "RTGS":
                    systemAccounts = limitSystemAccountRepository.findByAccountType(AccountTypeEnum.RTGS_PAYABLE_POOL.getName());
                    field3 = partnerApisRequest.getP4()+"|"+partnerApisRequest.getP3()+"|"+accountHolderName;
                    fee = partnerDASetup.getRtgsFlatFee();
                    serviceCharge = accountUtil.getServiceCharge(ServiceTypeEnum.RTGS, ChannelEnum.FT3, amount);
	    			break;
	    	}
            LimitReconTransactions transaction = new LimitReconTransactions().limitSystemAccount(systemAccounts).amount(amount)
                                .txnStatus(TransactionStatus.SUCCESS).settlementStatus(SettlementStatus.PENDING).field3(field3)
                                .partnerReferenceNumber(partnerApisRequest.getPartnerReferenceNo()).fees(fee).feesGst(accountUtil.getGst(fee))
                                .txnRefNo(accountUtil.getTxnCounter("PARTNER_CLIENT")).partner(partner).transactionType(TransactionableTypeEnum.FUND_TRANSFER)
                                .ownerType(LimitOwnerType.PARTNER_CLIENT).ownerId(partnerClient.getId()).mobileNumber(partnerClient.getMobileNumber())
                                .field5(partnerApisRequest.getP8()).purpose(partnerApisRequest.getP9());
            transaction.setServiceCharge(serviceCharge);
            limitAccountEntryService.fundTransfer(transaction, partnerClient);
	    	Boolean isPartnerDrivenNarration = (null != partnerDASetup.getPartnerDrivenNarration() && partnerDASetup.getPartnerDrivenNarration());
	    	if("IMPS".equals(partnerApisRequest.getP6()) && null != partnerDASetup.getImpsChannel() && ImpsPayoutsChannelEnum.MOBILEWARE.equals(partnerDASetup.getImpsChannel())) {
	        	String narration = isPartnerDrivenNarration ? (StringUtils.isNotBlank(transaction.getField5()) ? transaction.getField5() : partnerClient.getClientName()) : partnerClient.getClientName();
	        	log.info("narration: {}", narration);
	        	MobilewareApisResponse mobilewareApisResponse = mobileWareService.synchronousP2A(transaction, narration, partnerApisRequest.getP3(), partnerApisRequest.getP4(),partnerClientOpt.get().getClientName(),partnerClientOpt.get().getMobileNumber());
	        	if(null != mobilewareApisResponse && null != mobilewareApisResponse.getStatus() && "SUCCESS".equals(mobilewareApisResponse.getStatus())) {
	        		transaction.setField1(mobilewareApisResponse.getStatus() + "|" + mobilewareApisResponse.getResponseCode() + "|" + mobilewareApisResponse.getResponseMsg());
	        		transaction.setMerchantReferenceNumber(mobilewareApisResponse.getRrn());
	        		transaction.setSettlementStatus(SettlementStatus.SETTLED);
	        	} else if(null != mobilewareApisResponse && null != mobilewareApisResponse.getStatus() && "FAILURE".equals(mobilewareApisResponse.getStatus())) {
	        		limitAccountEntryService.reversal(transaction, TransactionableTypeEnum.AUTO_REVERSAL);
	        		transaction.setField1(mobilewareApisResponse.getStatus() + "|" + mobilewareApisResponse.getResponseCode() + "|" + mobilewareApisResponse.getResponseMsg());
	        		transaction.setSettlementStatus(SettlementStatus.REVERSED);
	        		transaction.setMerchantReferenceNumber(mobilewareApisResponse.getRrn());
	    			transaction.failureCode(mobilewareApisResponse.getResponseCode()).failureMessage(mobilewareApisResponse.getResponseMsg());
	        		transaction.isIgnored(Boolean.TRUE);
	        	} else if(null != mobilewareApisResponse && null != mobilewareApisResponse.getStatus() && "PENDING".equals(mobilewareApisResponse.getStatus())) {
					transaction.setField1(mobilewareApisResponse.getStatus()
					+ "|" + (StringUtils.isNotBlank(mobilewareApisResponse.getResponseCode()) ? mobilewareApisResponse.getResponseCode() : "")
					+ "|" + (StringUtils.isNotBlank(mobilewareApisResponse.getResponseMsg()) ? mobilewareApisResponse.getResponseMsg() : ""));
					transaction.setMerchantReferenceNumber(mobilewareApisResponse.getRrn());
	        	}
	        	limitReconTransactionsRepository.save(transaction);
			} else {
	    		neftImpsService.bankTransfer(transaction, partnerApisRequest.getP6(), accountHolderName, isPartnerDrivenNarration);
	    	}

	    	//Success Response
	    	if (Arrays.asList(SettlementStatus.PENDING, SettlementStatus.SETTLED).contains(transaction.getSettlementStatus())) {
                PartnerApisResponse partnerApisResponse = new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "00")));
                partnerApisResponse.setStatus("SUCCESS");
                partnerApisResponse.setPartnerReferenceNumber(partnerApisRequest.getPartnerReferenceNo());
                partnerApisResponse.setYppTxnReferenceNumber(transaction.getTxnReferenceNumber());
                return partnerApisResponse;
            } else {
	      		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA035")))
                  .downStreamErrorDetails(RandomUtil.getDownStreamAPIErrorDetailsJSON(transaction.getFailureCode(), transaction.getFailureMessage()));
            }
    	} catch(Exception ex) {
    		log.info("Exception in transfer funds: ", ex);
     		 return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_DCA_FUND_TRANSFER, "YPP", "", "DCA035")));
    	}
    }

    public BigDecimal getServiceCharge(ServiceTypeEnum serviceType, ChannelEnum channel, BigDecimal txnAmount) {
    	log.debug("Fetching ServiceCharge for serviceType: {}, channel: {}, txnAmount: {}", serviceType, channel, txnAmount);
    	BigDecimal serviceCharge = BigDecimal.ZERO;
    	if (null != serviceType && null != channel && null != txnAmount) {
    		Optional<ServiceChargesDetails> serviceChargesDetailsInfo = serviceChargesDetailsRepository.findTopByServiceTypeAndChannelAndStatusAndLowerSlabLessThanAndUpperSlabGreaterThanEqual(serviceType, channel, ServiceChargesDetailsStatusEnum.ACTIVE, txnAmount, txnAmount);
    	    if (serviceChargesDetailsInfo.isPresent()) {
    	    	ServiceChargesDetails serviceChargesDetails = serviceChargesDetailsInfo.get();
    	    	log.debug("Found ServiceChargesDetails with id: {} and chargeType: {}", serviceChargesDetails.getId(), serviceChargesDetails.getChargeType());
    	        if (ChargeTypeEnum.PERCENTAGE.equals(serviceChargesDetails.getChargeType())) {
    	        	serviceCharge = serviceChargesDetails.getServiceCharge().divide(new BigDecimal(100)).multiply(txnAmount).setScale(4, BigDecimal.ROUND_HALF_UP);
    	        } else {
    	        	serviceCharge = serviceChargesDetails.getServiceCharge();
    	        }
    	    }
    	}
    	log.debug("returning from serviceCharge method with serviceCharge: {}", serviceCharge);
    	return serviceCharge;
    }

    public BigDecimal getGst(BigDecimal amt) {
        log.info("Amount {}", amt);
        if (amt.compareTo(BigDecimal.ZERO) > 0) {
            ParameterManagement parameterManagement = parameterManagementRepository.findByName(ParameterManagementEnum.GST_RATE.name());
            BigDecimal gstPercentage = new BigDecimal(parameterManagement.getValue());
            return gstPercentage.divide(new BigDecimal(100)).multiply(amt).setScale(4, BigDecimal.ROUND_HALF_UP);
        }
        return BigDecimal.ZERO;
    }

    public String getTxnCounter(String txnType) {
        DATxnCounter tc = new DATxnCounter();
        tc.setTxnType(txnType);
        tc.setTimestamp(RandomUtil.dateFormat(Instant.now(), "yyMMddHH"));
        DATxnCounter daTxnCounter = daTxnCounterRepository.save(tc);
        log.info("{}", daTxnCounter);
        return daTxnCounter.getId().toString();
    }

    public void fundTransfer(LimitReconTransactions transaction, PartnerClient partnerClient) {
    	transaction = limitReconTransactionsRepository.save(transaction);
    	String txnSubType = getTxnSubType(transaction);
        String result = limitAccountEntryRepository.limitFundTransfer(transaction.getAmount(), TransactionableTypeEnum.FUND_TRANSFER.toString(), transaction.getId(), partnerClient.getLimitAccount().getId(), transaction.getLimitSystemAccount().getLimitAccount().getId(), transaction.getOwnerId(), transaction.getOwnerType().name(), txnSubType, transaction.getOwnerId().toString(), null, null);
        if ("Insufficient Balance".equals(result)) {
            throw new InsufficientBalanceException("No balance");
        } else if (!"success".equals(result)) {
            throw new StoredProcedureException("Fund Transfer Exception");
        }
    }

	public MobilewareApisResponse synchronousP2A(LimitReconTransactions transaction, String narration, String accountNo,
			String ifscCode, String remName, String remMob) {
		log.info("Inside LimitReconTransactions synchronousP2A mobileWare api");
		MobilewareApisResponse mobilewareApisResponse = new MobilewareApisResponse();
		MobileWareRequestDTO mobileWareRequestDTO = new MobileWareRequestDTO();
		try {
			mobileWareRequestDTO = this.getMobileWareRequest(transaction.getAmount(), transaction.getTxnReferenceNumber(), narration, accountNo, ifscCode, remName, remMob);
			ObjectMapper mapper = new ObjectMapper();
			mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
			String jsonRequest = mapper.writeValueAsString(mobileWareRequestDTO);
			log.info("encrypted request for mobileWare api: {}", jsonRequest);
			Map<String, String> headers = new HashMap<String, String>();
			headers.put("Content-Type", "application/json");
			String url = baseUrl + "/imps-ws/transaction/sync/" + channelId +"/"+ "p2a";
			String response = httpServiceUtil.post(url, headers, jsonRequest, timeout);
			log.info("response for mobileWare api: {}", response);
			MobileWareResponseDTO mobileWareResponseDTO  = new ObjectMapper().readValue(response, MobileWareResponseDTO.class);
			String responsePayloadJson = mobileWare.decrypt(mobileWareResponseDTO.geteResp());
			log.info("decrypted response for mobileWare api: {} , and transaction referance number : {}", responsePayloadJson, transaction.getTxnReferenceNumber());
			mobilewareApisResponse = new ObjectMapper().readValue(responsePayloadJson, MobilewareApisResponse.class);

		} catch(ConnectTimeoutException cte) {
			log.error("Timeout exception in LimitReconTransactions SynchronousP2A:", cte);
			transaction.setField1("999|Timeout");
			limitReconTransactionsRepository.save(transaction);
		} catch(Exception ex) {
			log.error("Exception in LimitReconTransactions SynchronousP2A:", ex);
		}
		return mobilewareApisResponse;
	}

	private MobileWareRequestDTO getMobileWareRequest(BigDecimal amount, String txnReferenceNumber, String narration, String accountNo, String ifscCode,String remName, String remMob) throws Exception {
		log.info("Inside mobile ware request generation txnRefernceNo {}", txnReferenceNumber);;
		MobileWareRequestDTO mobileWareRequestDTO = new MobileWareRequestDTO();
		MobilewareApisRequest mobilewareApisRequest = new MobilewareApisRequest(); 
		mobilewareApisRequest.setAmount(String.format("%.2f", amount));
		mobilewareApisRequest.setClientRefId(txnReferenceNumber);
		mobilewareApisRequest.setNarration(narration);
		mobilewareApisRequest.setToAccountNo(accountNo);
		mobilewareApisRequest.setToIFSC(ifscCode);
		mobilewareApisRequest.setRemitterName(remName);
		mobilewareApisRequest.setRemMobNo(remMob);
		String hashKey = mobileWare.generateHaskKey(String.format("%.2f", amount) + txnReferenceNumber + accountNo + ifscCode);
		log.info("hashkey {}", hashKey);
		mobilewareApisRequest.setHashKey(hashKey);
		log.info("request for mobileWare api: {}", mobilewareApisRequest);
		ObjectMapper mapper = new ObjectMapper();
		mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
		String json = mapper.writeValueAsString(mobilewareApisRequest);
		String encryptedString =  mobileWare.encrypt(json);
		mobileWareRequestDTO.seteReq(encryptedString);
		return mobileWareRequestDTO;
	}

	public String generateHaskKey(String key) {
		log.info("key {}", key);
		 StringBuilder lHashtext = new StringBuilder();
		 try {
			 MessageDigest md = MessageDigest.getInstance("SHA-256");
			 byte[] messageDigest = md.digest(key.getBytes());
			 BigInteger number = new BigInteger(1, messageDigest);
			 String lHashtext1 = number.toString(16);
			 lHashtext = lHashtext.append(lHashtext1);
			 while (lHashtext.length() < 32) {
			 lHashtext = lHashtext.insert(0, "0");
		 }
		 } catch (Exception ex) {
			 System.out.println(ex);
		 }
		 return lHashtext.toString();
	}

	public String encrypt(String message) throws Exception {

		String base64EncryptedString = "";
		try {
			MessageDigest md = MessageDigest.getInstance("SHA-256");
			byte[] digestOfPassword = md.digest(sercretKey.getBytes(StandardCharsets.UTF_8));
			byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
			byte[] iv = Arrays.copyOf(digestOfPassword, 16);
			SecretKey key = new SecretKeySpec(keyBytes, "AES");
			Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
			IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

			// For Encrypt
			cipher.init(Cipher.ENCRYPT_MODE, key,ivParameterSpec);

			byte[] plainTextBytes = message.getBytes(StandardCharsets.UTF_8);
			byte[] buf = cipher.doFinal(plainTextBytes);
			byte[] base64Bytes = Base64.encodeBase64(buf);
			base64EncryptedString = new String(base64Bytes);
		} catch (Exception nse) {
			throw new Exception("Invalid input String");
		}
		return base64EncryptedString;
	}

	public String decrypt(String message) throws Exception {
		String base64EncryptedString = "";
		try {
			MessageDigest md = MessageDigest.getInstance("SHA-256");
			byte[] digestOfPassword = md.digest(sercretKey.getBytes(StandardCharsets.UTF_8));
			byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
			byte[] iv = Arrays.copyOf(digestOfPassword, 16);
			SecretKey key = new SecretKeySpec(keyBytes, "AES");
			Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
			IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

			// For Decrypt
			cipher.init(Cipher.DECRYPT_MODE, key, ivParameterSpec);
			byte[] decordedValue = new Base64().decode(message.getBytes());
			byte[] buf = cipher.doFinal(decordedValue);
			base64EncryptedString = new String(buf);
		} catch (Exception nse) {
			throw new Exception("Invalid input String");
		}
		return base64EncryptedString;
	}

    public LimitReconTransactions reversal(LimitReconTransactions transactions, TransactionableTypeEnum transactionType) {
        List<LimitAccountEntry> lAccountEntryList = limitAccountEntryRepository.findByLimitReconTransactionsId(transactions.getId());
        log.info("LAE List size {} for txn id {}", lAccountEntryList.size(), transactions.getId());
        for (LimitAccountEntry accountEntry : lAccountEntryList) {
            BigDecimal amount = accountEntry.getAmount();
            List<LimitAccountTransactions> lAccountTransactionList = limitAccountTransactionsRepository.findByLimitAccountEntryId(accountEntry.getId());
            log.info("Limit Account Transaction size {} for LAE id {}", lAccountTransactionList.size(), accountEntry.getId());
            Long credit = null;
            Long debit = null;
            for (LimitAccountTransactions accountTransaction : lAccountTransactionList) {
                log.info("LAT id {}", accountTransaction.getId());
                if (AccountTransactionType.CREDIT.name().equals(accountTransaction.getAccountEntryType()))
                    debit = accountTransaction.getLimitAccount().getId();
                else
                    credit = accountTransaction.getLimitAccount().getId();
            }
            log.info("Credit id {} and debit id {}", credit, debit);
            boolean isSameMonth = transactions.getCreatedDate().atZone(ZoneId.of("Asia/Kolkata")).toLocalDateTime().getMonth().equals(accountEntry.getCreatedDate().atZone(ZoneId.of("Asia/Kolkata")).toLocalDateTime().getMonth());
            String txnRefNumber = null;
            String narration = null;
            
            if(LimitOwnerType.PARTNER_CONSUMER.equals(transactions.getOwnerType())) {
        		String poolAlias = "";
        		if (transactions != null && !StringUtils.isEmpty(transactions.getLimitSystemAccount().getPoolAlias())){
        			poolAlias = StringUtils.defaultString(transactions.getLimitSystemAccount().getPoolAlias());
        		}
    			narration = "Reversal of Rs. " + amount +" credited against " + poolAlias + " transaction done on " + DateUtil.convertDateToIST(transactions.getTxnDate(), "dd-MM-yyyy HH:mm:ss")+".";
    			txnRefNumber = transactions.getTxnReferenceNumber();
            }
            String result = limitAccountEntryRepository.daReversal(amount, transactionType.name(), transactions.getId(), credit, debit, transactions.getOwnerId(), transactions.getOwnerType().name(), isSameMonth, txnRefNumber, narration);
            log.info("Stored Procedure result : {}", result);
            if ("already reversed".equals(result)) {
                throw new StoredProcedureException("Transaction already reversed");
            } else if (!"success".equals(result)) {
                throw new StoredProcedureException("Stored Procedure Failed");
            }
            if (accountEntry.getTransactionType().equals(TransactionableTypeEnum.LIMIT_SOURCE_TRANSFER.name())) {
                String[] accountDetails = transactions.getField3().split("\\|");
                PartnerClientSourceAccount sourceAccount = sourceAccountRepository.findByPartnerClientIdAndAccountNumberAndIfscCode(transactions.getOwnerId(), accountDetails[1], accountDetails[0]).get();
                sourceAccount.setAmountTransferredBack(sourceAccount.getAmountTransferredBack().subtract(transactions.getAmount()));
                sourceAccountRepository.save(sourceAccount);
            }
        }
        transactions.settlementStatus(SettlementStatus.REVERSED).isIgnored(Boolean.TRUE).thirdPartyStatus(ThirdPartyStatus.FAIL);
        return limitReconTransactionsRepository.save(transactions);
    }

    public void bankTransfer(LimitReconTransactions transactions, String transferType, String creditorName, Boolean isPartnerDrivenNarration) {
    	try {
    	    DomesticPaymentsRequestDTO requestDTO = getDomesticPaymentsRequestDto(transactions, transactions.getPartner(), transactions.getAmount(), transferType, creditorName, isPartnerDrivenNarration);
    		ObjectMapper mapper = new ObjectMapper();
    		mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    		String json = mapper.writeValueAsString(requestDTO);
    		String response = dataPowerUtil.postJsonWithDataPower(domesticPaymenturl, json, Integer.parseInt(domesticPaymentsTimeout),true);
    		JSONObject responseJson = new JSONObject(response);
    		DomesticPaymentResponseDTO responseDTO = mapper.readValue(responseJson.toString(), DomesticPaymentResponseDTO.class);
            DomesticPaymentsDataDTO paymentsDataDTO = responseDTO.getData();
            if (paymentsDataDTO != null) {
                if (null != paymentsDataDTO.getStatus() && paymentsDataDTO.getStatus().equalsIgnoreCase("Received")) {
                    transactions.setField1(paymentsDataDTO.getStatus() + "|" + paymentsDataDTO.getTransactionIdentification());
                    if(null != paymentsDataDTO.getInitiation()) {
                        transactions.setMerchantReferenceNumber(paymentsDataDTO.getInitiation().getEndToEndIdentification());
                     }
                    limitReconTransactionsRepository.save(transactions);
                } else if (null != paymentsDataDTO.getStatus() && paymentsDataDTO.getStatus().equalsIgnoreCase("Failed")) {
                    limitAccountEntryService.reversal(transactions, TransactionableTypeEnum.AUTO_REVERSAL);
                    transactions.settlementStatus(SettlementStatus.REVERSED).isIgnored(Boolean.TRUE).transactionRemarks("Transaction not accepted");
                    if(null != paymentsDataDTO.getInitiation()) {
                        transactions.setMerchantReferenceNumber(paymentsDataDTO.getInitiation().getEndToEndIdentification());
                     }
                    MetaResponseDTO metaDTO = responseDTO.getMeta();
                    if (null != metaDTO) {
                        String field1 = paymentsDataDTO.getStatus() + "|" + metaDTO.getErrorCode() + "|" + metaDTO.getErrorSeverity();
                        transactions.setField1(StringUtils.substring(field1, 0, 254));
                        transactions.failureCode(metaDTO.getErrorCode()).failureMessage(metaDTO.getErrorSeverity());
                    }
                    limitReconTransactionsRepository.save(transactions);
                }
            }
    	} catch (InterruptedException | ConnectTimeoutException | SocketTimeoutException e) {
    		log.error("Timeout Exception ", e);
    		transactions.setField1("999|Timeout");
    		limitReconTransactionsRepository.save(transactions);
    	} catch (Exception ex) {
    		log.error("Exception ", ex);
    	}
    }

private DomesticPaymentsRequestDTO getDomesticPaymentsRequestDto(LimitReconTransactions transactions, Partner partner, BigDecimal amount, String transferType, String creditorName, Boolean isPartnerDrivenNarration) {
		LimitSystemAccount systemAccounts = transactions.getLimitSystemAccount();
		String debtorName = "YPP "+partner.getPartnerCode()+ " "+transferType+" Payable Pool";
        String[] accountDetails = transactions.getField3().split("\\|");

        DomesticPaymentsRequestDTO requestDTO = new DomesticPaymentsRequestDTO();
		DomesticPaymentsDataDTO dataDTO = new DomesticPaymentsDataDTO();
		dataDTO.setConsentId(consentId); // TODO
		DomesticPaymentsInitiationDTO initiationDTO = new DomesticPaymentsInitiationDTO();
		initiationDTO.setInstructionIdentification(transactions.getTxnReferenceNumber());
		initiationDTO.setInstructedAmount(new InstructedAmountDTO(amount.toString(), "INR"));

		DebtorAccountDTO debtorAccountDTO = new DebtorAccountDTO(); // DebtorAccount
		debtorAccountDTO.setIdentification(systemAccounts.getAccountNumber());
		debtorAccountDTO.setSecondaryIdentification(systemAccounts.getCustomerId());
		debtorAccountDTO.setName(debtorName);
		initiationDTO.setDebtorAccount(debtorAccountDTO);

		CreditorAccountDTO creditorAccountDTO = new CreditorAccountDTO();
		creditorAccountDTO.setSchemeName(accountDetails[0]);
		creditorAccountDTO.setIdentification(accountDetails[1]);
		creditorAccountDTO.setName(creditorName.replaceAll("[^a-zA-Z0-9 ]", ""));
		initiationDTO.setCreditorAccount(creditorAccountDTO);

		RemittanceInformationDTO remittanceInformationDTO = new RemittanceInformationDTO();
		String oldNarrationValue = "Fund Transfer /LM/ " + transactions.getTxnReferenceNumber();
		//Optional<PartnerClient> partnerClientOpt = this.partnerClientRepository.findById(transactions.getOwnerId()); // TODO need to confirm
        //String narration = partnerClientOpt.isPresent() ? RandomUtil.trimPartnerClientName(partnerClientOpt.get().getClientName()): oldNarrationValue;
		remittanceInformationDTO.setUnstructured(new RemittanceInformationUnstructuredDTO(isPartnerDrivenNarration ? (StringUtils.isNotBlank(transactions.getField5()) ? transactions.getField5() : oldNarrationValue) : oldNarrationValue)); // TODO
		initiationDTO.setRemittanceInformation(remittanceInformationDTO);
		initiationDTO.setClearingSystemIdentification(transferType);

		dataDTO.setInitiation(initiationDTO);
		requestDTO.setData(dataDTO);

		DomesticPaymentsRiskDTO paymentsRiskDTO = new DomesticPaymentsRiskDTO();
		DeliveryAddressDTO addressDTO = new DeliveryAddressDTO();
		PartnerAddress partnerAddress = partnerAddressRepository.findByPartner(partner).get();
		List<String> addressList = Arrays.asList(partnerAddress.getCity());
		addressList = addressList.stream()
				.map(address -> address.replaceAll("[^a-zA-Z0-9 ]", ""))
				.collect(Collectors.toList());
		addressDTO.setAddressLine(addressList); // TODO
		paymentsRiskDTO.setDeliveryAddress(addressDTO);

		requestDTO.setData(dataDTO);
		requestDTO.setRisk(paymentsRiskDTO);
		return requestDTO;
	}

    public LimitReconTransactions reversal(LimitReconTransactions transactions, TransactionableTypeEnum transactionType) {
        List<LimitAccountEntry> lAccountEntryList = limitAccountEntryRepository.findByLimitReconTransactionsId(transactions.getId());
        log.info("LAE List size {} for txn id {}", lAccountEntryList.size(), transactions.getId());
        for (LimitAccountEntry accountEntry : lAccountEntryList) {
            BigDecimal amount = accountEntry.getAmount();
            List<LimitAccountTransactions> lAccountTransactionList = limitAccountTransactionsRepository.findByLimitAccountEntryId(accountEntry.getId());
            log.info("Limit Account Transaction size {} for LAE id {}", lAccountTransactionList.size(), accountEntry.getId());
            Long credit = null;
            Long debit = null;
            for (LimitAccountTransactions accountTransaction : lAccountTransactionList) {
                log.info("LAT id {}", accountTransaction.getId());
                if (AccountTransactionType.CREDIT.name().equals(accountTransaction.getAccountEntryType()))
                    debit = accountTransaction.getLimitAccount().getId();
                else
                    credit = accountTransaction.getLimitAccount().getId();
            }
            log.info("Credit id {} and debit id {}", credit, debit);
            boolean isSameMonth = transactions.getCreatedDate().atZone(ZoneId.of("Asia/Kolkata")).toLocalDateTime().getMonth().equals(accountEntry.getCreatedDate().atZone(ZoneId.of("Asia/Kolkata")).toLocalDateTime().getMonth());
            String txnRefNumber = null;
            String narration = null;
            
            if(LimitOwnerType.PARTNER_CONSUMER.equals(transactions.getOwnerType())) {
        		String poolAlias = "";
        		if (transactions != null && !StringUtils.isEmpty(transactions.getLimitSystemAccount().getPoolAlias())){
        			poolAlias = StringUtils.defaultString(transactions.getLimitSystemAccount().getPoolAlias());
        		}
    			narration = "Reversal of Rs. " + amount +" credited against " + poolAlias + " transaction done on " + DateUtil.convertDateToIST(transactions.getTxnDate(), "dd-MM-yyyy HH:mm:ss")+".";
    			txnRefNumber = transactions.getTxnReferenceNumber();
            }
            String result = limitAccountEntryRepository.daReversal(amount, transactionType.name(), transactions.getId(), credit, debit, transactions.getOwnerId(), transactions.getOwnerType().name(), isSameMonth, txnRefNumber, narration);
            log.info("Stored Procedure result : {}", result);
            if ("already reversed".equals(result)) {
                throw new StoredProcedureException("Transaction already reversed");
            } else if (!"success".equals(result)) {
                throw new StoredProcedureException("Stored Procedure Failed");
            }
            if (accountEntry.getTransactionType().equals(TransactionableTypeEnum.LIMIT_SOURCE_TRANSFER.name())) {
                String[] accountDetails = transactions.getField3().split("\\|");
                PartnerClientSourceAccount sourceAccount = sourceAccountRepository.findByPartnerClientIdAndAccountNumberAndIfscCode(transactions.getOwnerId(), accountDetails[1], accountDetails[0]).get();
                sourceAccount.setAmountTransferredBack(sourceAccount.getAmountTransferredBack().subtract(transactions.getAmount()));
                sourceAccountRepository.save(sourceAccount);
            }
        }
        transactions.settlementStatus(SettlementStatus.REVERSED).isIgnored(Boolean.TRUE).thirdPartyStatus(ThirdPartyStatus.FAIL);
        return limitReconTransactionsRepository.save(transactions);
    }

	 public static DownStreamErrorDetailsDTO getDownStreamAPIErrorDetailsJSON(String code, String msg) {
		 if(StringUtils.isEmpty(code) && StringUtils.isEmpty(msg))
			 return null;
		 return new DownStreamErrorDetailsDTO(code, msg);
	 }