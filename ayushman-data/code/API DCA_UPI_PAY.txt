
YPP-14785 API DCA_UPI_PAY
====================================

public PartnerApisResponse daUpiDebit(PartnerApisRequest request, Partner partner) {
		log.info("Request to daUpiDebit {} for partner {}", request, partner.getId());
		try {
			if (StringUtils.isAnyBlank(request.getPartnerReferenceNo(), request.getP1(),request.getP2(), request.getP6())) {
				return new PartnerApisResponse(ErrorCodeService
						.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "P006")));
			}
			boolean isAccIfsc = StringUtils.isNoneBlank(request.getP3(), request.getP4());
			boolean isVpa = StringUtils.isNotBlank(request.getP5());
			if (!(isAccIfsc || isVpa)) {
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "P006")));
			}
			if (!request.getP1().matches("^[A-Za-z0-9]{3}$")) {
				log.info("Invalid Partner client {}", request.getP1());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA005")));
            } 
			if (!Arrays.asList(TransactionTypeEnum.FUND_TRANSFER.name(), TransactionTypeEnum.REFUND.name()).contains(request.getP2())) {
				log.info("Invalid Transaction Type {}", request.getP2());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "P006")));
			}
			if (StringUtils.isNotBlank(request.getP3()) && !request.getP3().matches("^[A-Za-z0-9]*$")) {
				log.info("Invalid Account Number {}", request.getP3());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA024")));
			}
			//Check for invalid IFSC code
	    	if(StringUtils.isNotBlank(request.getP4()) &&!RandomUtil.isValidIFSCode(request.getP4())) { 
	    		log.info("Invalid source account IFSC {}", request.getP4());
	    		return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA025")));
    		}
	    	// check for vpa 
	    	if (StringUtils.isNotBlank(request.getP5()) && !request.getP5().matches("^[a-zA-Z0-9.-]{2,256}@[a-zA-Z][a-zA-Z]{2,64}$")) {
	    		log.info("Invalid Beneficiary VPA {}", request.getP5());
	    		return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA026")));
    		}
			//Check for amount greater than 0
	    	BigDecimal amount;
	    	try {
	    		if (!(request.getP6().length()<=16)) {
					log.info("Invalid Amount ", request.getP6());
					return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA038")));
				}
	    		amount = new BigDecimal(request.getP6());
	    		if(!RandomUtil.validateAmount(amount)) {
	    			log.info("Invalid amount {}" , request.getP6());
	    			return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA038")));
	    		}
	    	} catch(Exception e) {
	    		log.info("Invalid amount {}" , request.getP6());
	    		return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA038")));
	    	}
			if ((request.getP2().equalsIgnoreCase(TransactionTypeEnum.REFUND.name()))) {
				if (StringUtils.isAnyBlank(request.getP7())) {
					return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "P006")));
				} else if(!request.getP7().matches("^[0-9]*$")) {
					return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA105")));
				}
			}
			if (StringUtils.isNotBlank(request.getP9()) && !(request.getP9().matches("^[A-Za-z0-9 ]*$"))) {
				log.info("Invalid Creditor Name ", request.getP9());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA107")));
			}
			if (StringUtils.isNotBlank(request.getP10()) && !(request.getP10().matches("^[0-9]{10}"))) {
				log.info("Invalid Creditor Mobile Number ", request.getP10());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA109")));
			}
			Optional<PartnerDASetup> partnerDASetupInfo = partnerDASetupRepository.findByPartnerId(partner.getId());
		    if (!partnerDASetupInfo.isPresent()) {
				log.info("Invalid client config missing {}", partner.getId());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA099")));
			}
		    PartnerDASetup partnerDASetup = partnerDASetupInfo.get();
		    Boolean partnerDrivenNarration = (null != partnerDASetup.getPartnerDrivenNarration() && partnerDASetup.getPartnerDrivenNarration());
			if(partnerDrivenNarration) {
				if(StringUtils.isAnyBlank(request.getP8())) {
					return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "P006")));
				}
			}
			if (StringUtils.isNotBlank(request.getP8()) && !(request.getP8().matches("^[A-Za-z0-9 ]*$")&& request.getP8().length()<=50 )) {
				log.info("Invalid Remarks ", request.getP8());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA074")));
			}
		    Boolean isPurposePresent = StringUtils.isNoneBlank(partnerDASetup.getAllowedPayoutPurposes());
			if (isPurposePresent) {
				if (StringUtils.isBlank(request.getP11())) {
					return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "P006")));
				}
				String[] split = partnerDASetup.getAllowedPayoutPurposes().split(",");
				if (!request.getP11().matches("[a-zA-Z0-9 _]+")) {
					log.info("Invalid Purpose", request.getP11());
					return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA080")));
				}
				List<String> purposes = Arrays.asList(partnerDASetup.getAllowedPayoutPurposes().split(","));
				if (!purposes.contains(request.getP11())) {
					log.info("Invalid Purpose {} for config Id {} with purposes {}", request.getP11(), partnerDASetup.getId(), partnerDASetup.getAllowedPayoutPurposes());
					return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA080")));
				}
			}
			//Check for partner reference number
	    	Optional<LimitReconTransactions> limitReconTransaction = this.limitReconTransactionsRepository.findByPartnerReferenceNumberAndPartnerId(request.getPartnerReferenceNo(),partner.getId());
	    	if(limitReconTransaction.isPresent()) {
	    		log.info("Invalid partner reference number {}", request.getPartnerReferenceNo());
	    		return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA023")));
	    	}
			Optional<PartnerClient> partnerClientInfo = partnerClientRepository.findByClientIdentifierAndPartnerId(request.getP1(), partner.getId());
			if (!partnerClientInfo.isPresent()) {
				log.info("Invalid Partner client {}", request.getP1());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA005")));
			}
			PartnerClient partnerClient = partnerClientInfo.get();
			if (partnerClient.getStatus().equals(Status.INACTIVE)) {
				log.info("Invalid Partner client {} not active", request.getP6());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA029")));
			}
			if(partnerClient.getIsSuspended()) {
				log.info("Client is suspended {}", partnerClient.getIsSuspended());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA102")));
			}
			if(!(partnerClient.getPurpose().equals(PartnerClientPurposeEnum.DC_AGGREGATOR))) {
				log.info("Invalid Client is not eligible for this purpose  {}", partner.getId());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA057")));
			}
			Optional<UpiSubMerchantDetails> upiSubMerchantDetailsInfo = upiSubMerchantDetailsRepository.findByOwnerIdAndOwnerTypeAndUpiOnboardingStatus(partnerClient.getId(), UpiSubMerchantDetailsOwnerTypeEnum.PARTNER_CLIENT ,UpiSubMerchantDetailsUpiOnboardingStatusEnum.SUCCESS);
			if (!upiSubMerchantDetailsInfo.isPresent()) {
				log.info("Merchant not created at switch {}", partner.getId());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA103")));
			}
			if (!UpiSubMerchantDetailsStatusEnum.ACTIVE.equals(upiSubMerchantDetailsInfo.get().getStatus())) {
				log.info("UPI Merchant is INACTIVE {}", upiSubMerchantDetailsInfo.get().getId());
				return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA115")));
			}
			//Check for sufficient balance present or not
	    	if(amount.compareTo(partnerClient.getActualBalance()) > 0) {
	    		log.info("Insufficient Amount  {} Current balance {}", amount , partnerClient.getActualBalance());
	    		return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA040")));
	    	}
			UpiSubMerchantDetails upiSubMerchantDetails = upiSubMerchantDetailsInfo.get();
			// accounting
			String field3 = isVpa
					? (request.getP5() + "|" + (StringUtils.isNotBlank(request.getP9()) ? request.getP9() : "") + "|"
							+ (StringUtils.isNotBlank(request.getP12()) ? request.getP12() : "") + "|"
							+ (StringUtils.isNotBlank(request.getP10()) ? request.getP10() : ""))
					: (request.getP3() + "|" + request.getP4() + "|"
							+ (StringUtils.isNotBlank(request.getP9()) ? request.getP9() : "") + "|"
							+ (StringUtils.isNotBlank(request.getP12()) ? request.getP12() : "") + "|"
							+ (StringUtils.isNotBlank(request.getP10()) ? request.getP10() : ""));
	    	BigDecimal fee = partnerDASetup.getUpiFee(amount);
            LimitSystemAccount systemAccounts = limitSystemAccountRepository.findByAccountType(AccountTypeEnum.MG_UPI_PAYABLE_POOL.getName());
            BigDecimal serviceCharge = accountUtil.getServiceCharge(ServiceTypeEnum.UPI, ChannelEnum.MINDGATE, amount);
            LimitReconTransactions transaction = new LimitReconTransactions().limitSystemAccount(systemAccounts).amount(amount)
                                .txnStatus(TransactionStatus.SUCCESS).settlementStatus(SettlementStatus.PENDING).field3(field3)
                                .partnerReferenceNumber(request.getPartnerReferenceNo()).fees(fee).feesGst(accountUtil.getGst(fee))
                                .txnRefNo(accountUtil.getTxnCounter("PARTNER_CLIENT")).partner(partner).transactionType(TransactionableTypeEnum.FUND_TRANSFER)
                                .ownerType(LimitOwnerType.PARTNER_CLIENT).ownerId(partnerClient.getId()).mobileNumber(partnerClient.getMobileNumber())
                                .field5(request.getP8()).purpose(request.getP11());
            transaction.setServiceCharge(serviceCharge);
	    	limitAccountEntryService.fundTransfer(transaction, partnerClient);
	    	try {
	    		MgApiRequestDto mgApiRequestDto = new MgApiRequestDto(Constants.DCA, getPayRequest(request, upiSubMerchantDetails, transaction, partnerClient, partnerDrivenNarration), upiSubMerchantDetails.getSubMerchantId());
	    		String apiResponse = null;
				if (Arrays.asList(env.getActiveProfiles()).contains("prod")) {
					apiResponse = commonApiService.commonMGApi(new JSONObject(mgApiRequestDto).toString(), payUrl);
				} else {
					apiResponse = dummyApiResponseRepository.findByKeyAndApiNameAndValue("Upi", ApiNameEnum.UPI_DEBIT, request.getPartnerReferenceNo()).orElse(new DummyApiResponse()).getApiResponse();
					if (StringUtils.isBlank(apiResponse))
						apiResponse = commonApiService.commonMGApi(new JSONObject(mgApiRequestDto).toString(), payUrl);
				}
	    		MgPayResponseParameterDto responseDto = new ObjectMapper().readValue(apiResponse, MgPayResponseParameterDto.class);
	    		if (responseDto != null) {
	                if (null != responseDto.getStatus() && (responseDto.getStatus().equalsIgnoreCase("S") || responseDto.getStatus().equalsIgnoreCase("SUCCESS"))) {
	                	transaction.settlementStatus(SettlementStatus.SETTLED).merchantReferenceNumber(responseDto.getRrn());
	                	transaction.setField1(responseDto.getStatus() + "|" + (StringUtils.isNotBlank(responseDto.getStatusDesc()) ? responseDto.getStatusDesc() : "") + "|" + (StringUtils.isNotBlank(responseDto.getResponseCode()) ? responseDto.getResponseCode() : ""));
	                	transaction.setField4(responseDto.getPyAccName());
	                	transaction.setTransactionRemarks(responseDto.getTxnId());
	                	limitReconTransactionsRepository.save(transaction);
	                } else if (null != responseDto.getStatus() && (responseDto.getStatus().equalsIgnoreCase("F") || responseDto.getStatus().equalsIgnoreCase("FAILURE"))) {
	                	limitAccountEntryService.reversal(transaction, TransactionableTypeEnum.AUTO_REVERSAL);
	                	transaction.settlementStatus(SettlementStatus.REVERSED).isIgnored(Boolean.TRUE).merchantReferenceNumber(responseDto.getRrn());
	                	String field1 = responseDto.getStatus() + "|" + (StringUtils.isNotBlank(responseDto.getErrorCode()) ? responseDto.getErrorCode() : "") + "|" + (StringUtils.isNotBlank(responseDto.getStatusDesc()) ? responseDto.getStatusDesc() : "");
	                	transaction.setField1(StringUtils.substring(field1, 0, 254));
	                	transaction.failureCode(responseDto.getErrorCode()).failureMessage(responseDto.getStatusDesc());
	                	transaction.setTransactionRemarks(responseDto.getTxnId());
	                	limitReconTransactionsRepository.save(transaction);
	                } else if (null != responseDto.getStatus() && (responseDto.getStatus().equalsIgnoreCase("P") || responseDto.getStatus().equalsIgnoreCase("T"))) {
	                	transaction.setField1(responseDto.getStatus() + "|" + (StringUtils.isNotBlank(responseDto.getStatusDesc()) ? responseDto.getStatusDesc() : "") + "|" + (StringUtils.isNotBlank(responseDto.getResponseCode()) ? responseDto.getResponseCode() : ""));
	                	limitReconTransactionsRepository.save(transaction);
	                }
	            }
	    	} catch (Exception e) {
	    		log.error("Exception in daUpiDebit: {}", e.getMessage(), e);
	    		transaction.setField1("999|Timeout");
	    		limitReconTransactionsRepository.save(transaction);
	    	}
	    	//Success Response
	    	if (Arrays.asList(SettlementStatus.SETTLED, SettlementStatus.PENDING).contains(transaction.getSettlementStatus())) {
                PartnerApisResponse partnerApisResponse = new PartnerApisResponse();
                
                if(SettlementStatus.SETTLED.equals(transaction.getSettlementStatus())) {
                	partnerApisResponse.setResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "00")));
                } else {
                	partnerApisResponse.setResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA121")));
                }
                
                partnerApisResponse.setStatus("SUCCESS");
                partnerApisResponse.setPartnerReferenceNumber(request.getPartnerReferenceNo());
                partnerApisResponse.setYppTxnReferenceNumber(transaction.getTxnReferenceNumber());
                partnerApisResponse.setChannelReferenceNumber(transaction.getMerchantReferenceNumber());
                partnerApisResponse.setBeneficiaryName(transaction.getField4());
                partnerApisResponse.setUpdatedBalance(limitAccountRepository.findCurrentBalanceByOwnerTypeAndOwnerId(AccountOwnerType.PARTNER_CLIENT.name(), partnerClient.getId()));
                return partnerApisResponse;
            } else {
	    	    return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA044"))).downStreamErrorDetails(RandomUtil.getDownStreamAPIErrorDetailsJSON(transaction.getFailureCode(), transaction.getFailureMessage()));
            }
		} catch (Exception e) {
			log.error("Exception in daUpiDebit: {}", e.getMessage(), e);
			return new PartnerApisResponse(ErrorCodeService.getMappedErrorCodeAndMessage(new ErrorCode(DCA_UPI_DEBIT, "YPP", "", "DCA044")));
		}
	}

    public BigDecimal getServiceCharge(ServiceTypeEnum serviceType, ChannelEnum channel, BigDecimal txnAmount) {
    	log.debug("Fetching ServiceCharge for serviceType: {}, channel: {}, txnAmount: {}", serviceType, channel, txnAmount);
    	BigDecimal serviceCharge = BigDecimal.ZERO;
    	if (null != serviceType && null != channel && null != txnAmount) {
    		Optional<ServiceChargesDetails> serviceChargesDetailsInfo = serviceChargesDetailsRepository.findTopByServiceTypeAndChannelAndStatusAndLowerSlabLessThanAndUpperSlabGreaterThanEqual(serviceType, channel, ServiceChargesDetailsStatusEnum.ACTIVE, txnAmount, txnAmount);
    	    if (serviceChargesDetailsInfo.isPresent()) {
    	    	ServiceChargesDetails serviceChargesDetails = serviceChargesDetailsInfo.get();
    	    	log.debug("Found ServiceChargesDetails with id: {} and chargeType: {}", serviceChargesDetails.getId(), serviceChargesDetails.getChargeType());
    	        if (ChargeTypeEnum.PERCENTAGE.equals(serviceChargesDetails.getChargeType())) {
    	        	serviceCharge = serviceChargesDetails.getServiceCharge().divide(new BigDecimal(100)).multiply(txnAmount).setScale(4, BigDecimal.ROUND_HALF_UP);
    	        } else {
    	        	serviceCharge = serviceChargesDetails.getServiceCharge();
    	        }
    	    }
    	}
    	log.debug("returning from serviceCharge method with serviceCharge: {}", serviceCharge);
    	return serviceCharge;
    }

  public BigDecimal getGst(BigDecimal amt) {
        log.info("Amount {}", amt);
        if (amt.compareTo(BigDecimal.ZERO) > 0) {
            ParameterManagement parameterManagement = parameterManagementRepository.findByName(ParameterManagementEnum.GST_RATE.name());
            BigDecimal gstPercentage = new BigDecimal(parameterManagement.getValue());
            return gstPercentage.divide(new BigDecimal(100)).multiply(amt).setScale(4, BigDecimal.ROUND_HALF_UP);
        }
        return BigDecimal.ZERO;
    }

    public String getTxnCounter(String txnType) {
        DATxnCounter tc = new DATxnCounter();
        tc.setTxnType(txnType);
        tc.setTimestamp(RandomUtil.dateFormat(Instant.now(), "yyMMddHH"));
        DATxnCounter daTxnCounter = daTxnCounterRepository.save(tc);
        log.info("{}", daTxnCounter);
        return daTxnCounter.getId().toString();
    }

    public void fundTransfer(LimitReconTransactions transaction, PartnerClient partnerClient) {
    	transaction = limitReconTransactionsRepository.save(transaction);
    	String txnSubType = getTxnSubType(transaction);
        String result = limitAccountEntryRepository.limitFundTransfer(transaction.getAmount(), TransactionableTypeEnum.FUND_TRANSFER.toString(), transaction.getId(), partnerClient.getLimitAccount().getId(), transaction.getLimitSystemAccount().getLimitAccount().getId(), transaction.getOwnerId(), transaction.getOwnerType().name(), txnSubType, transaction.getOwnerId().toString(), null, null);
        if ("Insufficient Balance".equals(result)) {
            throw new InsufficientBalanceException("No balance");
        } else if (!"success".equals(result)) {
            throw new StoredProcedureException("Fund Transfer Exception");
        }
    }

    public String commonMGApi(String apiRequestDto, String url) throws Exception {
    	HttpHeaders headers = new HttpHeaders();
    	headers.setContentType(MediaType.APPLICATION_JSON);
    	log.info("Request {} ", apiRequestDto);
    	HttpEntity<String> httpEntity = new HttpEntity<String>(apiRequestDto, headers);
    	ResponseEntity<String> resp = this.restTemplate.postForEntity(url, httpEntity, String.class);
    	log.info("Response {}", resp);
    	return resp.getBody();
    }

	private String getPayRequest(PartnerApisRequest request, UpiSubMerchantDetails upiSubMerchantDetails, LimitReconTransactions transaction, PartnerClient partnerClient, Boolean partnerDrivenNarration) {
		String payeeVpaType = null;
    	if (StringUtils.isNoneBlank(request.getP3(), request.getP4(), request.getP5()))
    		payeeVpaType = "VPA";
    	else if (StringUtils.isNoneBlank(request.getP3(), request.getP4()))
    		payeeVpaType = "Account";
    	else if (StringUtils.isNoneBlank(request.getP5()))
    		payeeVpaType = "VPA";
    	MgPayRequestParameterDto dto = new MgPayRequestParameterDto(upiSubMerchantDetails.getSubMerchantId(), transaction.getTxnReferenceNumber(), "UPI Payment for Partner Client",
    			transaction.getAmount().toString(), "INR", "P2P", "PAY", "7399", null, request.getP3(), request.getP4(), null, null, request.getP5(), null, null, null, null,
    			"UPI", request.getP9(), null, null, null, null, null, payeeVpaType);
		dto.setAdd9("NA");
		dto.setAdd10("NA");
		log.info("rawBody json: {}", new JSONObject(dto));
		String rawBodyValue = dto.getParameters();
		return rawBodyValue;
	}

public LimitReconTransactions reversal(LimitReconTransactions transactions, TransactionableTypeEnum transactionType) {
        List<LimitAccountEntry> lAccountEntryList = limitAccountEntryRepository.findByLimitReconTransactionsId(transactions.getId());
        log.info("LAE List size {} for txn id {}", lAccountEntryList.size(), transactions.getId());
        for (LimitAccountEntry accountEntry : lAccountEntryList) {
            BigDecimal amount = accountEntry.getAmount();
            List<LimitAccountTransactions> lAccountTransactionList = limitAccountTransactionsRepository.findByLimitAccountEntryId(accountEntry.getId());
            log.info("Limit Account Transaction size {} for LAE id {}", lAccountTransactionList.size(), accountEntry.getId());
            Long credit = null;
            Long debit = null;
            for (LimitAccountTransactions accountTransaction : lAccountTransactionList) {
                log.info("LAT id {}", accountTransaction.getId());
                if (AccountTransactionType.CREDIT.name().equals(accountTransaction.getAccountEntryType()))
                    debit = accountTransaction.getLimitAccount().getId();
                else
                    credit = accountTransaction.getLimitAccount().getId();
            }
            log.info("Credit id {} and debit id {}", credit, debit);
            boolean isSameMonth = transactions.getCreatedDate().atZone(ZoneId.of("Asia/Kolkata")).toLocalDateTime().getMonth().equals(accountEntry.getCreatedDate().atZone(ZoneId.of("Asia/Kolkata")).toLocalDateTime().getMonth());
            String txnRefNumber = null;
            String narration = null;
            
            if(LimitOwnerType.PARTNER_CONSUMER.equals(transactions.getOwnerType())) {
        		String poolAlias = "";
        		if (transactions != null && !StringUtils.isEmpty(transactions.getLimitSystemAccount().getPoolAlias())){
        			poolAlias = StringUtils.defaultString(transactions.getLimitSystemAccount().getPoolAlias());
        		}
    			narration = "Reversal of Rs. " + amount +" credited against " + poolAlias + " transaction done on " + DateUtil.convertDateToIST(transactions.getTxnDate(), "dd-MM-yyyy HH:mm:ss")+".";
    			txnRefNumber = transactions.getTxnReferenceNumber();
            }
            String result = limitAccountEntryRepository.daReversal(amount, transactionType.name(), transactions.getId(), credit, debit, transactions.getOwnerId(), transactions.getOwnerType().name(), isSameMonth, txnRefNumber, narration);
            log.info("Stored Procedure result : {}", result);
            if ("already reversed".equals(result)) {
                throw new StoredProcedureException("Transaction already reversed");
            } else if (!"success".equals(result)) {
                throw new StoredProcedureException("Stored Procedure Failed");
            }
            if (accountEntry.getTransactionType().equals(TransactionableTypeEnum.LIMIT_SOURCE_TRANSFER.name())) {
                String[] accountDetails = transactions.getField3().split("\\|");
                PartnerClientSourceAccount sourceAccount = sourceAccountRepository.findByPartnerClientIdAndAccountNumberAndIfscCode(transactions.getOwnerId(), accountDetails[1], accountDetails[0]).get();
                sourceAccount.setAmountTransferredBack(sourceAccount.getAmountTransferredBack().subtract(transactions.getAmount()));
                sourceAccountRepository.save(sourceAccount);
            }
        }
        transactions.settlementStatus(SettlementStatus.REVERSED).isIgnored(Boolean.TRUE).thirdPartyStatus(ThirdPartyStatus.FAIL);
        return limitReconTransactionsRepository.save(transactions);
    }